<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
   <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <title>OptiVec: Handbook</title>
   <link rel="stylesheet" media="screen" type="text/css" href="stylesheet.css">
</head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#ff0000">
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=280 alt="OptiVec logo">&nbsp;
</TD><TD><h1><I><b><font size="+4">OptiVec</font></b></I><BR>&nbsp;<BR>Version 7</h1>
<BR><h2>for C/C++, &nbsp; Delphi and Lazarus</h2>
</td></tr><tr><TD>
<I>OptiCode</I>
<BR>Dr. Martin Sander Software Development
<BR>Brahmsstr. 6
<BR>D-32756 Detmold
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:optivec@gmx.de">optivec@gmx.de</A>
</TD><TD><h1>Part I. A: Handbook</h1>
</TD></TR></TABLE>
<P>This HANDBOOK describes the basic principles of the <I>OptiVec</I> libraries and gives an overview over <I>VectorLib</I>, the first part of <I>OptiVec</I>. The object-oriented interface, <I>VecObj</I>, is described in <a href="#chap3">chapter 3</a>. The other parts have their own descriptions in separate files, see <a href="MATRIX.HTM">MATRIX.HTM</a> and <a href="CMATH.HTM">CMATH.HTM</a>.

<BR><a href="#chap1_2">Chapter 1.2</a> of this Handbook contains the licence terms for the Shareware version, <a href="#chap1_3_2">Chapter 1.3</a> for the Registered version.
<BR>&nbsp;
<BR><I>OptiCode</I>? and <I>OptiVec</I>? are trademarks of Dr. Martin Sander Software Dev. Other brand and product names mentioned in this handbook for identification purposes are trademarks or registered trademarks of their respective holders.
<BR>&nbsp;
<table width="100%"><tr><td width="10%"></TD>
<td><b>German-speaking users:</b>
<BR>Um die Kosten f&uuml;r das Herunterladen der Shareware-Version &uuml;ber das Internet f&uuml;r alle so gering wie m&ouml;glich zu halten, enth&auml;lt diese nur die englische Dokumentation. Sie finden die deutsche Beschreibung separat unter <a href="http://www.optivec.de/download/OVDOCD.ZIP">http://www.optivec.de/download/OVDOCD.ZIP</a>.</td></tr>
</table>

<a name="TOC"></a>
<H1>Contents</H1>
<a href="#chap1">1. Introduction</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap1_1">1.1 Why Vectorized Programming Pays Off on the PC</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%">&nbsp;</TD><td><a href="#chap1_1_1">1.1.1 General <i>OptiVec</i> Optimization Strategies</a></td></tr>
<tr valign="top"><td>&nbsp;</TD><td><a href="#chap1_1_2">1.1.2 Multi-Processor Optimization</a></td></tr>
<tr valign="top"><td>&nbsp;</TD><td><a href="#chap1_1_3">1.1.3 CUDA Device Support</a></td></tr>
<tr valign="top"><td>&nbsp;</TD><td><a href="#chap1_1_4">1.1.4 Choosing the right <i>OptiVec</i> Library</a></td></tr>
</table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap1_2">1.2 License Terms for the Shareware Version</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap1_3">1.3 Registered Versions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%">&nbsp;</TD><td><a href="#chap1_3_1">1.3.1 Registered Versions: Ordering</a></td></tr>
<tr valign="top"><td>&nbsp;</TD><td><a href="#chap1_3_2">1.3.2 License Terms for the Registered Versions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap1_4">1.4 Getting Started</a></td></tr></table>
<a href="#chap2">2. The Elements of <I>OptiVec</I> Routines</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap2_1">2.1 Synonyms for Some Data Types</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_2">2.2 Complex Numbers: The Data Types fComplex, dComplex, eComplex, fPolar, dPolar, and ePolar</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_3">2.3 Vectors and Arrays: The Data Types fVector, dVector, eVector, cfVector, pfVector, iVector, uVector, etc.</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_4">2.4 Real-Number Functions: The Prefixes <I>VF_,&nbsp; VD_</I>, and <I>VE_</I></a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_5">2.5 Complex-Number Functions: The Prefixes <I>VCF_,&nbsp; VCD_,&nbsp; VCE_,&nbsp; VPF_,&nbsp; VPD_</I>, and <I>VPE_</I></a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_6"> 2.6 Functions of the Integer Data Types: The Prefixes <I>VI_,&nbsp; VBI_,&nbsp; VSI_,&nbsp; VU_</I>, etc.</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_7">2.7 Common Functions of Several Data Types: The Prefix <I>V_</I></a></td></tr></table>
<a href="#chap3">3. C++ only: <I>VecObj</I>, the Object-Oriented Interface for <I>VectorLib</I></a>
<BR><a href="#chap4">4. <I>VectorLib</I> Functions and Routines: A Short Overview</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap4_1">4.1 Generation, Initialization and De-Allocation of Vectors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_2">4.2 Index-oriented Manipulations</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_3">4.3 Data-Type Interconversions</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_4">4.4 More about Integer Arithmetics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_5">4.5 Basic Functions of Complex Vectors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6">4.6 Mathematical Functions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%"></TD><td><a href="#chap4_6_1">4.6.1 Rounding</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_2">4.6.2 Comparisons</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_3">4.6.3 Direct Bit-Manipulation</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_4">4.6.4 Basic Arithmetics, Accumulations</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_5">4.6.5 Geometrical Vector Arithmetics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_6">4.6.6 Powers</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_7">4.6.7 Exponentials and Hyperbolic Functions</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_8">4.6.8 Logarithms</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_9">4.6.9 Trigonometric Functions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap4_7">4.7 Analysis</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_8">4.8 Signal Processing: Fourier Transforms and Related Topics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_9">4.9 Statistical Functions and Building Blocks</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_10">4.10 Data Fitting</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_11">4.11 Input and Output</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_12">4.12 Graphics</a></td></tr></table>
<a href="#chap5">5. Error Handling</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap5_1">5.1 General Remarks</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_2">5.2 Integer Errors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3">5.3 Floating-Point Errors</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%"></TD><td><a href="#chap5_3_1">5.3.1 C/C++ specific</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3_2">5.3.2 Pascal/Delphi specific</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3_3">5.3.3 Error Types (Both C/C++ and Pascal/Delphi)</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap5_4">5.4 The Treatment of Denormal Numbers</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_5">5.5 Advanced Error Handling: Writing Messages into a File</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_6">5.6 <I>OptiVec</I> Error Messages</a></td></tr></table>
<a href="#chap6">6. Trouble-Shooting</a>
<a href="#chap7">7. The Include-Files and Units of <I>OptiVec</I></a>
<BR>
<BR>P a r t I. B : File <a href="FUNCREF.HTM">FUNCREF.HTM</a> contains:
<BR>&nbsp;
<BR><a href="FUNCREF.HTM#chap8">8. Alphabetical Reference of Vector Functions</a>
<BR><a href="FUNCREF.HTM#chap9">9. Scalar (non-vectorized) Functions</a>

<P><a name="chap1"></a>
<HR width="100%"><H1>1. Introduction</H1>
<P><I>OptiVec</I> offers a powerful set of routines for numerically demanding applications, making the philosophy of vectorized programming available for C/C++ and Pascal/Delphi languages. It serves to overcome the limitations of loop management of conventional compilers &#x2013; which proved to be one of the largest obstacles in the programmer's way towards efficient coding for scientific and data analysis applications.
<P>In contrast to integrated packages like MatLab or others, <I>OptiVec</I> has the advantage of being incorporated into the modern and versatile languages C/C++ and Pascal/Delphi. Both C++ and Fortran do already offer some sort of vector processing, by virtue of iterator classes using templates (C++) and field functions (Fortran90). Both of these, however, are basically a convenient means of letting the compiler write the loop for you and then compile it to the usual inefficient code. The same is true for most implementations of the popular BLAS (Basic Linear Algebra Subroutine) libraries. <BR>
In comparison to these approaches, <I>OptiVec</I> is superior mainly with respect to execution speed &#x2013; on the average by a factor of 2-3, in some cases even up to 8. The performance is no longer limited by the quality of your compiler, but rather by the real speed of the processor!
<P>There is a certain overlap in the range of functions offered by <I>OptiVec</I> and by BLAS, LINPACK, and other libraries and source-code collections. However, the latter must be compiled, and, consequently, their performance is determined mainly by the quality of the compiler chosen. To the best of our knowledge, <I>OptiVec</I>, was. in 1996, the first product on the market offering a comprehensive vectorized-functions library realized in a true Assembler implementation.
<UL>
<LI>All operators and mathematical functions of C/C++ and Pascal/Delphi are implemented in vectorized form; additionally many more mathematical functions are included which normally would have to be calculated by more or less complicated combinations of existing functions. Not only the execution speed, but also the accuracy of the results is greatly improved.
<LI>A wide range of optimized matrix functions like matrix arithmetics, algebra, decompositions, data fitting, etc. is offered by <a href="MATRIX.HTM"><I>MatrixLib</I></a>.
<BR>TensorLib is planned as a future extension of these concepts for general multidimensional arrays.
<LI>Fast Fourier Transform techniques (both one- and two-dimensional) allow for efficient convolutions, correlation analyses, spectral filtering, and so on.
<LI>Building blocks for statistical data analysis are supplied.
<LI>Derivatives, integrals, interpolation schemes are included.
<LI>Graphical representation of data offers a convenient way of monitoring the results of vectorized calculations.
<LI>Each function exists for every data type for which this is reasonable. The data type is signalled by the prefix of the function name. No implicit name mangling or other specific C++ features are used in the C/C++ version, which makes <I>OptiVec</I> usable in plain-C as well as in C++ programs. Moreover, the names and the syntax of nearly all functions are the same in C/C++ and Pascal/Delphi languages.
<LI>The input and output vectors/matrices of <I>VectorLib</I> and <I>MatrixLib</I> routines may be of variable size and it is possible to process only a part (e.g., the first 100 elements, or every 10th element) of a vector, which is another important advantage over other approaches, where only whole arrays are processed.
<LI>A new object-oriented interface for C++, named <I>VecObj</I>, encapsulates all vector functions, offering even easier use and increased memory safety.
<LI>Using <I>OptiVec</I> routines instead of loops can make your source code much more compact and far better readable.
<LI>Besides the vectorized complex-number functions, <I><a href="CMATH.HTM">CMATH</a></I> is included. This is a comprehensive library of complex operations and functions, both in cartesian and polar coordinates. In comparison to complex class libraries shipped with C++ compilers and to the unit Complex of Delphi (or UComplex of Lazarus), <I>CMATH</I> is generally much faster, more complete, more accurate and numerically stable.
</UL>
<P>The wide range of routines and functions covered by <I>OptiVec</I>, the high numerical efficiency and increased ease of programming make this package a powerful programming tool for scientific and data analysis applications, competing with (and often beating) many high-priced integrated systems, but imbedded into your favourite programming language.

<P>This documentation describes the <I>OptiVec</I> implementations for
<UL>
<LI>Embarcadero / Borland / CodeGear C++ (all versions of RAD Studio and Borland C++ Builder; even Borland C++ versions back to 5.0 still work) for Win32 and Win64 (native Win32 / Win64 only; no .NET applications!).
<LI>Microsoft Visual C++ (all version of Microsoft Visual Studio and Visual C++ down to Visual Studio 2005) both for 64-bit and for 32-bit Windows on PC platforms.
<LI>Embarcadero / Borland Delphi, versions 7, 2005 through 2010, XE Series, 10 Seattle/Berlin/Tokyo, on 32-bit and 64-bit Windows
<LI>Lazarus / FreePascal, exclusively for the 64-bit Windows platform.
</UL>
Please note that only the &quot;outside appearance&quot; and thus the documentation is the same for these different compilers. The libraries themselves are compiler-specific; each library can be used only with one compiler and, in the case of C/C++, with one memory model or one target:
<OL>
<LI><U>Shareware Versions</U>
<BR>The Shareware version contains only a selection of libraries:
<OL><LI><u>64-bit:</u> P8 (General-Purpose library, back-compatible to Core2 / AMD64) and P9M (automatic multi-threading, up-to-date processors required: Haswell+ / Excavator+).
<LI><u>32-bit:</u> P4D: General-Purpose debug version, using the FPU for maximum floating-point accuracy, safety and widest processor compatibility range - down to 486DX / Pentium / Athlon. In order to prevent memory errors, possibly occurring through the violation of vector and matrix boundaries, this debug version checks all input vectors / matrices and their sizes for consistency. Additionally, all overflow, singularity, and loss-of-precision errors lead to an error message.<BR>This version runs on all 32-bit Windows versions (including the 32-bit mode of 64-bit Windows).
<LI><u>32-bit:</u> P8M: Multi-Core library for use on AMD64 x2,  Core2 Duo or their multi-core successors. In addition to the automatic distribution of the work load over the available processor cores (auto-threading), the speed is also enhanced by employing SSE, SSE2, SSE3 etc. command sets for many floating-point operations. Be prepared, however, to accept a certain loss of accuracy as a consequence of the use of SSE commands. Overflow, singularity, and loss-of-precision errors are treated "silently" by setting the default result as indicated in the documentation of each function.
</OL>&nbsp;

<LI><U>Full Registered Versions</U>
<BR>The libraries come in several versions of processor utilization: 
<UL><LI>P4 &nbsp;(widest processor compatibility range, down to 486DX / Pentium / Athlon for all 32-bit Windows versions)
<LI>P8 &nbsp;(min. Core2xxx or AMD64xxx)
<BR>siginificantly faster through the use of SSE, SSE2, SSE3 commands.
<LI>P9 &nbsp;(at least Intel Core i 4th generation (Haswell), AMD Excavator)
<BR>again siginificantly faster through the use of AVX, AVX2, and FMA3 instructions.
</UL>
These versions are differentiated into sub-versions:
<UL><LI>Normal Version:
<BR>Optimized for smaller vectors / matrices with up to several 100 elements, calculations running in a single thread.
<LI>Debug Version with dimension-consistency checking:
<BR>In order to prevent hard-to-track memory errors, possibly occurring through the violation of vector and matrix boundaries, this debug version checks all input vectors / matrices and their sizes for consistency. It is highly recommended to use the debug libraries during the debugging phase of application development and switch to the higher-performance versions only after you have made sure that no memory issues, as detected by the debug libraries, remain unsolved. Additionally, all overflow, singularity, and loss-of-precision errors lead to an error message. In the C/C++ versions, they are treated the old-fashioned way via <i>matherr()</i>. (In contrast to the Debug library, from version 6.1 on, all other libraries treat these errors silently by setting the result to the default value indicated in the documentation.)
<LI>Multi-Processor Version:
<BR>For larger vectors and matrices, the work load can be distributed among several processor cores. Thereby, the performance can theoretically be multiplied by the number of available processor cores. The Multi-Processor version initiates additional worker threads which, in turn, are attributed to the processor units by the operating system. Every function checks if the work can reasonably be distributed (auto-threading).
<BR>The decision, if the multi-processor version should be employed, strongly depends on the nature of the desired calculations. The reason lies in the inter-thread communication "bureaucracy" involved in the auto-threading mechanism. Only from a certain vector / matrix size on, these overhead losses can be earned back. For the transcendental functions of complex arguments, this is the case already at vector lengths of 60-80 elements, whereas, for a function like VF_addV, the performance scales with the number of processors only from about 10,000 elements on. Normally, the decision between the normal and the multi-processor version will be made just by trying both.
<BR>An application, linked with the multi-processor library, runs without problems on a single-processor computer. However, the speed will typically be 10-20% slower than with the normal library.
<LI>CUDA Version:
<BR>This is a multi-processor version which goes even one step further: It checks, if processing of large vectors / matrices can be outsourced to a CUDA device. In order to use this library version, you must have a CUDA-enabled NVIDIA graphics card (or dedicated hardware like Tesla, Fermi, or Kepler board) installed in your computer. Be sure also visit www.nvidia.com to download and install the latest driver for your graphics card. On the positive side, even a sub-100$ graphics card can speed up certain operations by an amazing factor of 10. There are drawbacks, however: Getting this version up and running is not always trivial, so we recommend this version only for use on your own computer (not for applications distributed for others). 
</UL>
</OL>

<H4>Specifics of the <i>OptiVec</i> versions for the different compilers</H4>
<UL><LI><U>Embarcadero / Borland / CodeGear C++:</U>
<BR><u>32-bit:</u> You have to choose between static and dynamic BC++ run-time library and link VCFS.LIB + VCF4D.LIB with the static BC++ RTL, but VCFD.LIB + VCF4D.LIB with the dynamic RTL.
<BR><u>64-bit:</u> There is no difference between static and dynamic BC++ run-time library. Link OVBCx64.a + OVBC64_8.a or OVBC64_8M.a.
<LI><U>Microsoft Visual C++:</U>
<BR>The Shareware version comes with libraries for &quot;multi-thread debug&quot;, and &quot;multi-thread DLL debug&quot;. The full (registered) version contains additional libraries for the corresponding release runtimes. As each version of Visual Studio comes with its own runtime DLL, <i>OptiVec</i> contains version-specific libraries to be used only with Visual Studio 2005, 2008, 2010 and so on.
<LI><U>Delphi:</U>
<BR>Each Delphi release requires its own <i>OptiVec</i> library version. Only Delphi 2006 and 2007 share the same <i>OptiVec</i> units.
<LI><U>Lazarus:</U>
<BR>All <i>OptiVec</i> routines are <b>cdecl</b>. This means their names are case-sensitive, and you have to write them exactly as in the documention. The technical reason for this is that, in the other calling models, Lazarus decorates all function names with encoded type information. So the <i>OptiVec</i> function names would not be found in the included *.o files.
</UL>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_1"></a>
<H2>1.1 Why Vectorized Programming Pays Off on the PC</H2>
To process one-dimensional data arrays or &quot;vectors&quot;, a programmer would normally write a loop over all vector elements. Similarly, two- or higher-dimensional arrays (&quot;matrices&quot; or &quot;tensors&quot;) are usually processed through nested loops over the indices in all dimensions. The alternative to this classic style of programming are vector and matrix functions.
<BR>Vector functions act on whole arrays/vectors instead of single scalar arguments. They are the most consequent form of &quot;vectorization&quot;, i.e., organisation of program code (by clever compilers or by the programmer himself) in such a way as to optimize vector treatment.

<P>Vectorization has always been the magic formula for supercomputers with their multi-processor parallel architectures. On these architectures, one tries to spread the computational effort equally over the available processors, thus maximizing execution speed. The so-called &quot;divide and conquer&quot; algorithms break down more complicated numerical tasks into small loops over array elements. Sophisticated compilers then find out the most efficient way how to distribute the array elements among the processors. Many supercomputer compilers also come with a large set of pre-defined proprietary vector and matrix functions for many basic tasks. These vectorized functions offer the best way to achieve maximum throughput.

<p>Obviously, the massive parallel processing of, say, a Cray is not possible even on modern PCs with their modest 2, 4 or 8-processor core configurations. Consequently, at first sight, it might seem difficult to apply the principle of vectorized programming to the PC. Actually, however, there are many vector-specific optimizations possible, even for computers with only one CPU. Most of these optimizations are not automatically available to present compilers. Rather, one has to go down to the machine-code level. <b>Hand-optimized, Assembler-written vector functions outperform compiled loops by a factor of two to three, on the average.</b> This means that vectorization, properly done, is indeed worth the effort, also for PC programs. 

<P><a name="chap1_1_1"></a>
<H3>1.1.1 General <i>OptiVec</i> Optimization Strategies</H3>
<p>Here are the most important optimization strategies, employed in <I>OptiVec</I> to boost the performance on any PC (regardless of the number of processor cores):

<P><B>Preload of constants</B><BR>Floating-point as well as integer constants, employed in the evaluation of mathematical functions, are loaded into registers outside of the actual loop and stay as long as they are needed. This saves a large amount of loading/unloading operations which are necessary if a mathematical function is called for each element of a vector separately.

<P><B>Prefetch of chunks of vector elements</B><BR>Beginning with the Pentium III processor, Intel introduced the very useful feature of explicit memory prefetch. With these commands, it is possible to "tell" the processor to fetch data from memory sufficiently in advance, so that no time is wasted waiting for them when they are actually needed.

<P><B>Full XMM and FPU stack usage</B><BR>Where necessary, all eight (64-bit: all sixteen) XMM registers and/or all eight coprocessor registers are employed.

<P><B>Use of SIMD commands</B><BR>You might wonder why this strategy is not listed first. The SSE or "Streaming Single-Instruction-Multiple-Data Extensions", introduced since the days of the Pentium III and improved with every new processor generation, provide explicit support for vectorized programming with floating-point data in <B>float / single</B> or <B>double</B> precision. At first sight, therefore, they should revolutionize vector programming. Given the usual relation between processor and data bus speeds, however, many of the simple arithmetic operations are data transfer limited, and the use of SIMD commands does not make the large difference (with respect to well-written FPU code) it could make otherwise. In many cases, the advantage of using an SIMD instruction instead of separate FPU instructions melts down to a 20-30% increase in speed (which is not that bad, anyway!). For more complicated operations, on the other hand, SIMD commands often cannot be employed, either because conditional branches have to be taken for each vector element individually, or because the "extra" accuracy and range, available by traditional FPU commands (with their internal <B>extended</B> accuracy), allows to simplify algorithms so much that the FPU code is still faster. As a consequence, we use SIMD commands only where a real speed gain is possible. Please note, however, that, the SIMD-employing library versions (P8, P9 etc.) generally sacrifice 1-2 digits of accuracy in order to attain the described speed gain. If this is not acceptable for your specific task, please stay with the P4 libraries.

<P><B>Superscalar scheduling</B><BR>By careful &quot;pairing&quot; of commands whose results do not depend upon each other, the parallel integer pipes and <FONT FACE="Courier New">fadd/fmul</FONT> units of the processor are used as efficiently as possible.

<P><B>Loop-unrolling</B><BR>Where SIMD instructions cannot be used and where optimum pairing of commands cannot be achieved for single elements, vectors are often processed in chunks of two, four, or even more elements. This allows to fully exploit the parallel execution pipes. Moreover, the relative amount of time spent for loop management is significantly reduced. In connection with data-prefetching, described above, the depth of the unrolled loops is most often adapted to the cache line size.

<P><B>Simplified addressing</B><BR>The addressing of vector elements is still a major source of inefficiency with present compilers. Switching forth and back between input and output vectors, a large number of redundant addressing operations is performed. The strict (and easy!) definitions of all <I>OptiVec</I> functions allow to reduce these operations to a minimum.

<P><B>Replacement of floating-point by integer commands</B><BR>For any operations with floating-point numbers that can also be performed using integer commands (like copying, swapping, or comparing to preset values), the faster method is consistently employed.

<P><B>Strict precision control</B><BR>C compilers convert a <B>float</B> into a <B>double</B> &#x2013; Borland Pascal/Delphi even into <B>extended</B> &#x2013; before passing it to a mathematical function. This approach was useful at times when disk memory was too great a problem to include separate functions for each data type in the .LIB files, but it is simply inefficient on modern PCs. Consequently, no such implicit conversions are present in <I>OptiVec</I> routines. Here, a function of a <B>float</B> is calculated to <B>float</B> (i.e. single) precision, wasting no time for the calculation of more digits than necessary &#x2013; which would be discarded anyway. There is also a brute-force approach to precision-control: You can call <font face="courier new"><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a>( 1 );</font> to actively switch the FPU to single precision, if that is enough for a given application. Thereby, execution can be slightly sped up from Pentium CPUs on. Be, however, prepared to accept even lower-than-single accuracy of your end results, if you elect this option. For further details and precautions, see <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.

<P><B> All-inline coding</B><BR>All external function calls are eliminated from the inner loops of the vector processing. This saves the execution time necessary for the &quot;<FONT FACE="Courier New">call / ret</FONT>&quot; pairs and for loading the parameters onto the stack.

<P><B>Cache-line matching of local variables</B><BR>
The Level-1 cache of modern processors uses 64-byte lines. Many <I>OptiVec</I> functions need double-precision or extended-precision real local variables on the stack (mainly for integer/floating-point conversions or for range checking). 32-bit compilers align the stack on 4-byte boundaries, which means there is a certain chance that the 8 bytes of a <B>double</B> or the 10 bytes of an <B>extended</B>, stored on the stack, will cross a cache-line boundary. This, in turn, would lead to a cache line-break penalty, deteriorating the performance. Consequently, those <I>OptiVec</I> functions where this is an issue, use special procedures to align their local variables on 8-byte (for <B>double</B>s), 16-byte  (for <B>extended</B>s), or 64-byte boundaries (for XMM and YMM values).

<P><B>Unprotected and reduced-range functions</B><BR>
<I>OptiVec</I> offers alternative forms of some mathematical functions, where you have the choice between the fully protected variant with error handling and another, unprotected variant without. In the case of the integer power functions, for example, the absence of error checking allows the unprotected versions to be vectorized much more efficiently. Similarly, the sine and cosine functions can be coded more efficiently for arguments that the user can guarantee to lie in the range -2<FONT FACE="Symbol">p</FONT> and +2<FONT FACE="Symbol">p</FONT>. In these special cases, the execution time may be reduced by up to 40%, depending on the hardware environment. This increased speed has always to be balanced against the increased risk, though: If any input element outside the valid range is encountered, the unprotected and reduced-range functions will crash without warning.

<P><a name="chap1_1_2"></a>
<H3>1.1.2 Multi-Processor Optimization</H3>
<P><B>Multithread support</B><BR>
Modern multi-core processors allow the operating system to distribute threads among the available processors, scaling the overall performance with the number of available processor cores. For that, any functions running in parallel must be prevented from interfering with each other through read/write operations on global variables. With very few exceptions (namely the plotting functions, which have to use global variables to store the current window and coordinate system settings), all other <I>OptiVec</I> functions are reentrant and may run in parallel. 
<P>When designing your multi-thread application, you have two options: functional parallelism and data parallelism.
<P><B>Functional Parallelism</B><BR>
If different threads are performing different tasks &#x2013; they are functionally different &#x2013; one speaks of functional parallelism. As an example, consider one thread handling user input / output, while another one performs background calculations. Even on a single-core CPU, this kind of multi-threading may offer advantages (e.g., the user interface does not block during extensive background calculations, but still takes input). On a multi-core computer, the two (or more) threads can actually run simultaneously on the different processor cores. In general, however, the load balance between the processor cores is far from perfect: often, one processor is running at maximum load, while another one is sitting idle, waiting for input. Still, functional multithreading is the best option whenever your numerical tasks involve vectors and matrices of only small-to-moderate size. 
<P><B>Data Parallelism</B><BR>
In order to improve the load balance between the available processor cores, thereby maximizing throughput, it is possible to employ classical parallel processing: the data to be processed is split up into several chunks, each thread getting one of these chunks. This is aptly called data parallelism. The usefulness of this approach is limited by the overhead involved in the data distribution and in the thread-to-thread communication. Moreover, there are always parts of the code which need to be processed sequentially and cannot be parallelized. Therefore, data parallelism pays off only for larger vectors and matrices.  Typical break-even sizes range from about 100 (for the calculation of transcendental functions of complex input values) to several 10,000 elements (as in the simple arithmetic functions). Only when your vectors and matrices are considerably larger than that threshold, the performance is actually improved over a functional-parallelism approach. The boost then quickly approaches (but never exactly reaches) the theoretical limit of a factor equal to the number of processor cores available.
<P><a name="chap1_1_3"></a>
<H3>1.1.3 CUDA Device Support</H3>
Modern graphics cards are equipped with powerful multiprocessor capacity of up to several hundred processor kernels running in parallel. In recent years, interfaces have been developed, allowing to exploit this processing capacity not only for graphics rendering, but also for general calculations. One of these approaches is the CUDA concept by NVIDIA. All current NVIDIA graphics cards support CUDA. Additionally, dedicated CUDA hardware is being offered by NVIDIA for high-performance computing. With the <i>cudaOptiVec</i> libraries (marked by a "C" in the library name, e.g., OVVC8<u>C</u>.LIB or OVBC64_8<u>C</u>.a), <i>OptiVec</i> offers a simple way to use a CUDA device for vector / matrix calculations without the hassles of actually programming in CUDA. There are a number of points to be considered:
<UL><LI>Obviously, the <i>cudaOptiVec</i> libraries can be used only with a CUDA-enabled device installed. This means, only NVIDIA products are supported.
<LI>Already a sub-100$ graphics card can boost the performance of certain functions on a computer with a medium-range CPU by a factor of 10, dedicated hardware by much more. However, the combination of a high-end CPU with a low-end graphics card (as it is often found in laptop computers) will only marginally benefit from the <i>cudaOptiVec</i> libraries. 
<LI>The cost of swapping data forth and back between main-board memory and graphics memory is so high that it can be "earned" back only for quite large vectors and matrices. E.g., for mathematical functions like the sine or exponential functions, CUDA pays off only from several 1,000 vector elements on.
<LI>Using CUDA with <i>OptiVec</i> can be as easy as simply linking with the <i>cudaOptiVec</i>libraries instead of the standard <i>OptiVec</i> libs. No modifications of your source code are necessary at this stage.
<LI>If you <i>are</i> willing to modify your source code, however, there are, ways to greatly improve performance over this most simple approach. To this end, the <i>cudaOptiVec</i> libraries offer various sets of functions, distinguished by their prefixes:
	<UL><LI><b>VF_,  VFx_ etc.</b> (the "normal" prefixes):   Automatic use of the CUDA device.  All <i>OptiVec</i> functions check if using the CUDA device makes sense and decide accordingly wether to source-out processing to the graphics processor or to stay on the CPU. This decision mechanism is far from perfect, as it cannot easily "know" how good your graphics card is in relation to your CPU.
	<LI><b>VFcu_, VFxcu_, etc.</b> (add "cu" to the original prefix, right before the underbar): Forced use of the CUDA device. Use of these prefixes makes most sense if you switch off the automatic mechanism by calling <a href="CUDAOPTIVEC.HTM#setAutoCudaUse">V_setAutoCudaUse(&nbsp;0&nbsp;)</a>;
	<LI><b>cudaVF_, cudaVFx_, etc.</b> (prepend the original prefix by "cuda"): Work on the CUDA device, processing vectors / matrices which have already been transferred into device memory (or into <a href="CUDAOPTIVEC.HTM#chap3">pinned host memory</a>). In order to use these prefixes, you have to manage the memory transfers yourself. <i>cudaOptiVec</i> offers the necessary interface functions to do that.
 </UL>
<LI>NVIDIA might at any time change the licence terms for their CUDA libraries. While we do expect NVIDIA to maintain their open policy, there can be no guarantee as to permanent support of CUDA by <i>OptiVec</i>.
<LI>For a step-by-step introduction into using <i>OptiVec</i> for CUDA, see <a href="CUDAOPTIVEC.HTM">CudaOptiVec.HTM</a>
</UL>
<P><a name="chap1_1_4"></a>
<H3>1.1.4 Choosing the right <i>OptiVec</i> Library</H3>
Whenever you want your application to run on a wide range of supported platforms, and when your vectors and matrices are only of small-to-moderate size, we recommend to use the <b>general-purpose libraries</b>,  OVVC4.LIB &nbsp;(for MS Visual C++), &nbsp;VCF4W.LIB &nbsp;(Embarcadero/Borland C++ compiler series), &nbsp;or the units in OPTIVEC\LIB4 &nbsp;(for Delphi). These libraries combine good performance with back-compatibility to older hardware, even down to 486DX, Pentium, Athlon. They are all multi-thread safe and support <u>functional</u> parallelism. If you do not need full floating-point accuracy and that amount of back-compatibility, you can get higher performance by switching to the P8 (or soon also P9) libraries (marked by the respective number in the in the library name).
<P>For large vectors/matrices on multi-core machines, <b>multi-core optimized libraries</b> actively distribute the work load over the available processor cores for <u>data</u> parallel execution. These libraries are marked by the letter "M", as in &nbsp;OVVC8M.LIB &nbsp;(for MS Visual C++, using SSE2), &nbsp;VCF4M.LIB &nbsp;(for Embarcadero/Borland C++, full FPU accuracy), &nbsp;or the units in OPTIVEC\LIB8M &nbsp;(for Delphi, using SSE3). These libraries are designed for AMD 64 x2, &nbsp;&nbsp; Intel Core2 Duo, or machines equipped with several discrete processors of the Pentium 4+ level. The CUDA libraries are based on the "M" libraries and are marked by the letter "C", as, e.g., in &nbsp;OVVC8C.LIB.
<BR>The "M" and "C" libraries will still run on single-core machines, but &#x2013; due to the thread-management overhead &#x2013; somewhat slower than the general-purpose libraries. Although the "M" libraries are designed with medium to large vectors in mind, the penalty for using them with smaller vectors is almost negligible, as the <i>OptiVec</i> thread-engine automatically executes a function in a single thread, if the vector size is too small for parallel execution to earn back the cost involved in the thread-to-thread communication.
<BR>If you use the "M" or "C" libraries, your programme must call <I><a href="FUNCREF.HTM#initMT">V_initMT(&nbsp;nAvailProcCores&nbsp;)</a></I> before any of the vector functions. 

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_2"></a>
<H2>1.2 Licence Terms for the Shareware Version</H2>
The following licence terms apply to the Shareware version of <I>OptiVec</I>.
For the licence terms of the Registered version, please see paragraph <a href="#chap1_3_2">1.3</a>.
<BR>&nbsp;<BR>This is the Shareware version of <I>OptiVec</I> (&quot;SOFTWARE&quot;).
<BR>It may be used under the following licence terms:
<OL>
<LI>You may test the SOFTWARE free of charge for a period of up to 90 days on one computer. 
<LI>Applications, created with the Shareware version of this SOFTWARE, will run only on the same computer on which this SOFTWARE has been installed. They cannot and may not be distributed to others. After the end of the trial period, they will cease functioning.
<LI>If you want to continue using this SOFTWARE after testing, and/or if you wish to distribute programs containing functions of this SOFTWARE, you have to purchase the registered version (see <a href="#chap1_3">chapter 1.3</a>).
<LI>This SOFTWARE is provided on an &quot;as is&quot; basis. Any explicit or implicit warranties for the SOFTWARE are excluded.
<LI>Despite thorough testing of the SOFTWARE, errors and bugs cannot be excluded with certainty. No claims as to merchantability or fitness for a particular purpose are made.
<LI>You may not use the SOFTWARE in any environment or situation where personal injury or excessive damage to anyone's property (including your own) could arise from malfunctioning of the SOFTWARE.
<LI>You may not decompile, disassemble, or otherwise reverse engineer the SOFTWARE into a machine-readable form. You may, however, inspect the functions it contains by means of debuggers like those included in the Borland and Microsoft compilers.
</OL>
Copyright for the SOFTWARE and its documentation &copy; 1996-2017 <I>OptiCode</I> &#x2013; Dr. Martin Sander Software Dev.
<BR>All rights reserved, including those of translation into foreign languages.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_3"></a>
<H2>1.3 Registered Versions</H2>
<P><a name="chap1_3_1"></a>
<H2>1.3.1 Registered Versions: Ordering</H2>
In order to make this product affordable also for those who will not themselves make money using it, we offer an <U>educational edition</U> at a strongly reduced rate, in addition to the full <U>commercial edition</U>. The contents of these two editions is identical. The only difference lies in the restrictions of use: The <U>educational edition</U> may not be used for commercial / business / government purposes, but is restricted to private and educational use. 
<P>Purchasing the full (registered) version gives you the right to use it on as many computers at a time as the number of units you bought.
<P>The right to distribute applications employing functions of <I>OptiVec</I> is included in the <U>commercial-version</U> licence. <B>No run-time licence are needed for your customers! </B> Corporate site and world-wide licences are available upon request.

<P>The full versions (both the commercial and the educational editions) of <I>OptiVec</I>
<UL><LI>support all targets of 64-bit and 32-bit Windows: GUI and Console, with static and with dynamic run-time library (Borland / CodeGear C++)<BR>
<LI>single-thread, multi-thread, multi-thread DLL debug and release for Win64 and Win32 (Microsoft Visual C++)<BR>
<LI>Delphi 7, 2005 through 2010, the XE series, and 10.x (Embarcadero / Borland / CodeGear Delphi, RAD Studio)<BR>
<LI>have individually optimized libraries for each degree of floating-point treatment / processor backward-compatibility:
<BR>P9 (requiring Intel Haswell+ or AMD Excavator+)
<BR>P8 (requiring Intel Core2xxx or AMD64xxx+)
<BR>P4: full FPU accuracy, optimized for Pentium II, requiring 486DX/Pentium+
<LI>(C/C++ versions only:) come with free printed documentation (which, however, is updated much less frequently than the electronic documentation).<BR>
<LI>entitle you to two years of free updates (by downloading from our web site)<BR>
<LI>can be ordered the following ways:
<BR><a href="#International">a) International orders</a> by Internet
<BR><a href="#EU">b) Orders within the European Union</a> (pre-paid or upon invoice)
</UL>
<a name="International"></a>
<h3>a) International Orders: Pricing</h3>
<H4><I>OptiVec</I> for C++ Builder (Embarcadero / Borland C/C++),&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;Delphi,&nbsp;&nbsp; or Lazarus&nbsp;/&nbsp;FreePascal</H4> 
<table border><tr valign="TOP"><td>&nbsp;</td><td>Commercial Edition&nbsp;</td><td>Educational Edition</td></tr>
<tr valign="TOP"><td>1 unit</td><td>USD &nbsp;&nbsp;249</td><td>USD &nbsp;&nbsp;&nbsp;&nbsp;99</td></tr>
<tr valign="TOP"><td>5 units</td><td>USD &nbsp;&nbsp;699 (139.80 per unit)</td><td>USD &nbsp;&nbsp;324.50 (64.90 per unit)</td></tr>
<tr valign="TOP"><td>10 units&nbsp;</td><td>USD 1199 (119.90 per unit)</td><td>USD &nbsp;&nbsp;499.00 (49.90 per unit)</td></tr></table>
<BR>Add applicable VAT.
<H4><I>CMATH</I> for C++ Builder (Embarcadero / Borland C/C++),&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;Delphi,&nbsp;&nbsp; or Lazarus&nbsp;/&nbsp;FreePascal separately</H4>
<table border><tr valign="TOP"><td>&nbsp;</td><td>Commercial Edition&nbsp;</td><td>Educational Edition</td></tr>
<tr valign="TOP"><td>1 unit</td><td>USD &nbsp;&nbsp;&nbsp;&nbsp;60</td><td>USD &nbsp;&nbsp;&nbsp;&nbsp;39</td></tr>
<tr valign="TOP"><td>5 units</td><td>USD &nbsp;&nbsp;200 (40.00 per unit)</td><td>USD &nbsp;&nbsp;124.50 (24.90 per unit)</td></tr>
<tr valign="TOP"><td>10 units&nbsp;</td><td>USD &nbsp;&nbsp;350 (35.00 per unit)</td><td>USD &nbsp;&nbsp;199.00 (19.90 per unit)</td></tr></table>
<BR>Add applicable VAT.

<h3>International: Ordering Options</h3>
For your protection, we handle credit-card orders through our specialized partner, ShareIt!
<BR>When ordering online through ShareIt, please use the product-specific links below:<BR>&nbsp;
<table  width="100%"><tr valign="TOP"><td><A HREF="http://shareit1.element-5.de/programs.html?productid=101557" TARGET="_blank"> <I>OptiVec</I> for C++ Builder - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=102654" TARGET="_blank">dto. - Educational</A></td><td>&nbsp;&nbsp;</td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=101353" TARGET="_blank"><I>CMATH</I> for C++ Builder - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=102655" TARGET="_blank">dto. - Educational</A></td></tr>
<tr valign="TOP"><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103421" TARGET="_blank"> <I>OptiVec</I> for MS Visual C++ - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=149811" TARGET="_blank">dto. - Educational</A></td><td>&nbsp;&nbsp;</td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103422" TARGET="_blank"><I>CMATH</I> for Visual C++ - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103441" TARGET="_blank">dto. - Educational</A></td></tr>
<tr valign="TOP"><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103843" TARGET="_blank"> <I>OptiVec</I> for Delphi - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103859" TARGET="_blank">dto. - Educational</A></td><td>&nbsp;&nbsp;</td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103844" TARGET="_blank"><I>CMATH</I> for Delphi - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=103860" TARGET="_blank">dto. - Educational</A></td></tr>
<tr valign="TOP"><td><A HREF="http://shareit1.element-5.de/programs.html?productid=300772360" TARGET="_blank"> <I>OptiVec</I> for Lazarus / FPC - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=300772361" TARGET="_blank">dto. - Educational</A></td><td>&nbsp;&nbsp;</td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=300772362" TARGET="_blank"><I>CMATH</I> for Lazarus / FPC - Commercial</A></td><td><A HREF="http://shareit1.element-5.de/programs.html?productid=300772365" TARGET="_blank">dto. - Educational</A></td></tr>
</table>

<a name="EU"></a>
<h3>b) Orders in the European Union, Iceland, Norway, Switzerland</h3>
If you can pay in Euro and order directly from the author, the pricing is
<H4><I>OptiVec</I> for Embarcadero / Borland C/C++,&nbsp;&nbsp;Delphi,&nbsp;&nbsp;or  Microsoft Visual C++<BR>
(CD-ROM, printed handbook outdated, but still available for the C/C++ versions in English or German)</H4>
<H4><I>OptiVec</I> for C++ Builder (Embarcadero / Borland C/C++),&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;Delphi,&nbsp;&nbsp; or Lazarus&nbsp;/&nbsp;FreePascal</H4> 
<table border><tr valign="TOP"><td>&nbsp;</td><td>Commercial Edition&nbsp;</td><td>Educational Edition</td></tr>
<tr valign="TOP"><td>1 unit</td><td>EUR &nbsp;&nbsp;199</td><td>EUR &nbsp;&nbsp;&nbsp;&nbsp;89</td></tr>
<tr valign="TOP"><td>5 units</td><td>EUR &nbsp;&nbsp;649 (129.80 per unit)</td><td>EUR &nbsp;&nbsp;299.50 (59.90 per unit)</td></tr>
<tr valign="TOP"><td>10 units&nbsp;</td><td>EUR 1099 (109.90 per unit)</td><td>EUR &nbsp;&nbsp;449.00 (44.90 per unit)</td></tr></table>
<BR>(incl. 19% German VAT, plus EUR 5,- handling charge in case of postal delivery).
<H4><I>CMATH</I> for C++ Builder (Embarcadero / Borland C/C++),&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;Delphi,&nbsp;&nbsp; or Lazarus&nbsp;/&nbsp;FreePascal separately</H4>
<table border><tr valign="TOP"><td>&nbsp;</td><td>Commercial Edition&nbsp;</td><td>Educational Edition</td></tr>
<tr valign="TOP"><td>1 unit</td><td>EUR &nbsp;&nbsp;&nbsp;&nbsp;59</td><td>EUR &nbsp;&nbsp;&nbsp;&nbsp;39</td></tr>
<tr valign="TOP"><td>5 units</td><td>EUR &nbsp;&nbsp;199 (39.20 per unit)</td><td>EUR &nbsp;&nbsp;124.50 (24.90 per unit)</td></tr>
<tr valign="TOP"><td>10 units&nbsp;</td><td>EUR &nbsp;&nbsp;349 (34.90 per unit)</td><td>EUR &nbsp;&nbsp;199.00 (19.90 per unit)</td></tr></table>
<BR>(incl. 19% German VAT, plus EUR 5,- handling charge in case of postal delivery).

<P><b>If you have a European VAT ID, or if you order from outside the European Union, you are exempt from German VAT, and it will be deduced from your bill, but you may have to pay your local VAT and/or import duties according to local laws.</b><BR>

<P>Please send a print-out of this <A HREF="ORDFORM1.HTM">order form</A> to
<P><I>OptiCode</I> &#x2013; Dr. Martin Sander Software Dev.
<BR>Brahmsstr. 6
<BR>D-32756 Detmold
<BR>Germany
<P>FAX +49 - 5231 - 70 17 782

<P>For any other questions related to ordering <I>OptiVec</I>, please contact us at: <A HREF="mailto:optivec@gmx.de">optivec@gmx.de</A>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_3_2"></a>
<h3>1.3.2 License Terms for the Registered version</h3>
If you got this file with the registered version of <I>OptiVec</I>, these are the license terms valid for you:
<BR>&nbsp;<BR>This is a single copy license for <I>OptiVec</I> (&quot;SOFTWARE&quot;), granted by <I>OptiCode</I> &#x2013; Dr. Martin Sander Software Development (&quot;<I>OptiCode</I>&quot;).
<P>The SOFTWARE in this package is licensed to you as the user. It is not sold. The term &quot;user&quot; means a programmer who links binary code of this SOFTWARE into his own applications. Those people using, in turn, his applications without the need of installing this SOFTWARE themselves, do not need any runtime license for the SOFTWARE. The right to distribute applications containing code of this SOFTWARE is included in the license fee  for the <U>commercial version</U>.
<P>Once you have paid the required license fee, you may use the SOFTWARE for as long as you like, provided you do not violate the copyright and if you observe the following rules:
<OL>
<LI>You may use the SOFTWARE on any computer for which it is designed, as long as not more than one person uses it at any time.<BR>
<LI>You may make backup copies of the SOFTWARE for your personal use. You may only transfer the SOFTWARE to somebody else if you transfer the original and all copies, retaining no copies for yourself. You may not lease or rent the SOFTWARE to others.<BR>
<LI>You may not decompile, disassemble, or otherwise reverse engineer the SOFTWARE into a machine-readable form. You may, however, inspect the functions contained in this SOFTWARE by means of debuggers like those included in the Borland and Microsoft compilers.<BR>
<LI>If you payed the reduced licence fee for the &quot;educational version&quot; rather than the full rate for the &quot;commercial version&quot;, the use of this SOFTWARE is restricted to private and educational purposes. In this case, you may not use the SOFTWARE for commercial purposes or for government purposes other than education. 
<BR>Applications using functions of this SOFTWARE may be freely distributed (i.e. without any run-time licence) only if created with the &quot;commercial edition&quot; and on condition that the functions of this SOFTWARE are permanently linked into a program etc., but do not appear as a library to the user of that application.<BR>
<LI>You may not use the SOFTWARE in any environment or situation where personal injury or excessive damage to anyone's property (including your own) could arise from malfunctioning of the SOFTWARE.<BR>
<LI><I>OptiCode</I>'s liability is limited by the enclosed Limited Warranty. In no case shall <I>OptiCode</I>'s liability exceed the license paid for the right to use the SOFTWARE.
</OL>
<BR><B><U>Limited Warranty for the Registered version</U></B>
<OL><LI><I>OptiCode</I> warrants that the magnetic or optic media on which the SOFTWARE is recorded are free from defects in materials and workmanship under normal use. The SOFTWARE itself will perform substantially in accordance with the specifications set forth in the documentation.<BR>
<LI>The above express warranties are made for a period of six months from the date the SOFTWARE is delivered to you as the first user.<BR>
<LI>Any magnetic/optic or printed media from this package proving defective in materials or workmanship will be replaced on an exchange basis.<BR>
<LI>Great care has been taken to ensure that the SOFTWARE operates in accordance with the specifications as described in the documentation. However, it is not guaranteed that this SOFTWARE will operate completely free of errors or that the documentation is free of errors.<BR>
<LI>Any implied warranties including any warranties of merchantability or of fitness for a particular purpose are limited to the terms of the above express warranties.<BR>
<LI><I>OptiCode</I> shall not in any case be liable for special, incidental, consequential, indirect or other damages arising from any breach of these warranties or of the license conditions, even if he has been notified of the possibility of such damages.
</OL>
<BR>Copyright for the SOFTWARE and its documentation &copy; 1996-2017 <I>OptiCode</I> &#x2013; Dr. Martin Sander Software Development. All rights reserved.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_4"></a>
<H2>1.4 Getting Started</H2>
To install <I>OptiVec</I>, please follow these steps:
<OL>
<LI>In order to use <I>OptiVec</I>, you need an already installed copy of your C/C++, Delphi, or Lazarus / FreePascal compiler. Install <I>OptiVec</I> by executing SETUP.EXE from the root directory of the installation disk or CD-ROM. Normally, <I>OptiVec</I> will be installed into a directory named &quot;OPTIVEC&quot;. This directory holds the documentation.<BR>&nbsp;
<LI>Include the <I>OptiVec</I> lib and include (C/C++) or units (Pascal/Delphi) subdirectories into the search path.<BR>&nbsp;
<LI><U>a) C/C++:</U>
<BR>Assuming your <I>OptiVec</I> directory is C:\OPTIVEC, add
<BR>C:\OPTIVEC\LIB to the library search path and
<BR>C:\OPTIVEC\INCLUDE to the include-file search path of the IDE (and of the configuration file BCC32.CFG in case you are using Borland's command-line compilers).<BR>&nbsp;
<BR><U>b) Delphi:</U>
<BR>The 32-bit units (.DCU files) will be installed into the directories OPTIVEC\LIB4D, &nbsp; OPTIVEC\LIB8M, etc.<BR>&nbsp;The 64-bit units go into OPTIVEC\Win64\LIB8, &nbsp;OPTIVEC\Win64\LIB9M etc.
<BR>When switching from the Shareware version to the Registered version, simply copy the .DCU units of the registered version over those of the Shareware version.
<BR><U>c) Lazarus:</U>
<BR>The units (.PPU files) and object files (*.o) will be installed into the directories OPTIVEC\LIB8, &nbsp; OPTIVEC\LIB9M, etc.
<LI>Choose the desired platform, target, and configuration:
<OL><LI><U>Embarcadero / Borland C++:</U>
<BR>You have to include two <i>OptiVec</i> libraries: First the <i>OptiVec</i> base library, OVBCx64.a for 64-bit,  VCFS.LIB (interface to the static runtime library of BC++) or VCFD.LIB (interface to the dynamically-linked runtime library of BC++) for 32-bit. Second, select the required processor-specific library from the following table (add the suffix .LIB for 32-bit or .a for 64-bit) and add it to your project. 
<table border width="100%">
<tr valign="top"><td>Processor</td><td>General-purpose</td><td>Debug</td><td>Multi-Processor</td><td>MP+CUDA</td><TD>64-bit General</TD><TD>64-bit Debug</TD><TD>64-bit MP</TD><TD>64-bit MP+CUDA</TD></tr>
<tr valign="top"><td>P8: AMD64xxx, Core2xxx</td><td>VCF8W.LIB</td><td> ---- </td><td>VCF8M.LIB</td><td>VCF8C.LIB</td><TD>OVVC64_8</TD><TD>OVBC64_8D</TD><TD>OVBC64_8M</TD><TD>OVBC64_8C</TD></tr>
<tr valign="top"><td>P4: Full FPU accuracy, 486DX/Pentium</td><td>VCF4W.LIB</td><td>VCF4D.LIB</td><td>VCF4M.LIB</td><TD> ---- </TD><TD> ---- </TD><TD> ---- </TD><TD> ---- </TD><TD> ---- </TD></tr>
</table>&nbsp;<BR>
The libraries for multi-processor systems run on workstations with discrete processors, as well as on multi-core processors like AMD64x2, Core2 Duo and so on.
<P>In order to profit from the CUDA-enhanced <i>OptiVec</i> library, do the following things:
<OL><LI>In addition to the <i>OptiVec</i> base library selected above, include the base import library OVBCCU32.lib (32-bit) or OVBCCU64.a (64-bit).</LI>
<LI>Make sure the corresponding DLL, OVBCCU32.DLL or OVBCCU64.DLL is either in the same directory as the executable you are about to create, or in another directory contained in the Windows environment variable PATH.</LI>
<LI>Include the processor-specific OptiVec library, ending with the letter "C", e.g. VCF8C.LIB or OVBC64_8C.lib. 
</LI></OL>
<BR>&nbsp;
<LI><U>Visual C++:</U> You have to include two <i>OptiVec</i> libraries. The first one ("base library") contains the interface between <i>OptiVec</i> and the VC++ runtime library; it has to be matched with the specific version of the VC++ runtime library you chose for your project. The second one is independent from the configuration and runtime library; you have to choose it according to the desired CPU support. 
<BR>First choose the project configuration and runtime library. The latter is set at <font face="Courier new">Project / (Configuration) Settings / C/C++ / Code Generation / Runtime Library</font>. Under <font face="Courier new">Project / (Configuration) Settings / Linker / Input</font>, add the matching <I>OptiVec</I> library to your project, according to the following table.<BR>&nbsp;

<table border width="100%">
<tr valign="top"><td>Platform</td><td>Visual Studio version</td><td>Runtime Debug DLL</td><td>Debug Static</td><td>Release DLL</td><td>Release Static</td></tr>
<tr valign="top"><td><b>Win64</b></td><td>VS 2015</td><td>OVVC14x64MDD.LIB</td><td>OVVCx64MTD.LIB</td><td>OVVC14x64MDR.LIB</td><td>OVVCx64MTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2013</td><td>OVVC12x64MDD.LIB</td><td>OVVCx64MTD.LIB</td><td>OVVC12x64MDR.LIB</td><td>OVVCx64MTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2012</td><td>OVVC11x64MDD.LIB</td><td>OVVCx64MTD.LIB</td><td>OVVC11x64MDR.LIB</td><td>OVVCx64MTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2010</td><td>OVVC8x64MDR.LIB<sup>*</sup></td><td>OVVCx64MTD.LIB</td><td>OVVC8x64MDR.LIB</td><td>OVVCx64MTR.LIB<sup>*</sup></td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2008</td><td>OVVC8x64MDR.LIB<sup>*</sup></td><td>OVVCx64MTD.LIB</td><td>OVVC8x64MDR.LIB<sup>*</sup></td><td>OVVCx64MTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2005</td><td>OVVC8x64MDD.LIB</td><td>OVVCx64MTD.LIB</td><td>OVVC8x64MDR.LIB</td><td>OVVCx64MTR.LIB</td></tr>
<tr valign="top"><td><b>Win32</b></td><td>VS 2015</td><td>OVVC14MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC14MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2013</td><td>OVVC12MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC12MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2012</td><td>OVVC11MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC11MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2010</td><td>OVVC10MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC10MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2008</td><td>OVVC9MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC9MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
<tr valign="top"><td>&nbsp;</td><td>VS 2005</td><td>OVVC8MDD.LIB</td><td>OVVCMTD.LIB</td><td>OVVC8MDR.LIB</td><td>OVVCMTR.LIB</td></tr>
</table>&nbsp;<BR>
<sup>*</sup>For the 64-bit DebugDLL and ReleaseDLL configurations with VS 2008 and VS 2010, the proper base library is not available. As a work-around, you can use the release-version of the VS 2005 library, OVVC8x64MDR.LIB. Additionally, you need the VS 2005 Redistributable. You find it at <a href="http://www.microsoft.com/download">www.microsoft.com/download</a>. Enter "vcredist_x64" into the search field to get a list of available redistributables and choose the VS 2005 one. You will get linker warnings about a library conflict, which you can ignore in this specific case.
<P>Please note that there is a certain inconsistency in the description of the configurations in Visual Studio: The default configurations "Debug" and "Release" actually use the runtime library and MFC as DLL. Therefore, you have to use the OptiVec base libraries OVVC??MDD.lib and OVVC??MDR.lib with these configurations. There is a problem with using these configurations, however: you always need the RTL and MFC DLL's for the specific compiler version installed on your computer. For many applications, it is therefore recommended to change Project / Properties / Configuration Properties / C/C++ / Code Generation / Runtime Library into "Multi-Thread Debug (/MTd)" or "Multi-Thread Release (MT)", respectively, in order to get rid of the DLL redistributables. This is done in the "DebugStatic" configuration in the demo files coming with <i>OptiVec</i>.
<P>After that, please add the second, processor-specific <i>OptiVec</i> library according to the following table:
<table border width="100%">
<tr valign="top"><td>Processor</td><td>General-purpose library</td><td>Debug library</td><td>Multi-Processor</td><td>MP + CUDA</td><TD>64-bit General</TD><TD>64-bit Debug</TD><TD>64-bit Multi-Proc.</TD><TD>64-bit MP + CUDA</TD></tr>
<tr valign="top"><td>P8: AMD64xxx, Core2xxx</td><td>OVVC8.LIB</td><td> ---- </td><td>OVVC8M.LIB</td><td>OVVC8C.LIB</td><td>OVVC64_8.LIB</td><td>OVVC64_8D.LIB</td><td>OVVC64_8M.LIB</td><td>OVVC64_8C.LIB</td></tr>
<tr valign="top"><td>P4: Full FPU accuracy, 486DX/Pentium</td><td>OVVC4.LIB</td><td>OVVC4D.LIB</td><td>OVVC4M.LIB</td><td> ---- </td><td> ---- </td><td> ---- </td><td> ---- </td><td> ---- </td></tr>
</table>&nbsp;<BR>
The libraries for multi-processor systems run on workstations with discrete processors, as well as on multi-core processors like AMD64x2, Core2 Duo and so on.
<BR>In order to allow <I>OptiVec</I> to be used in applications both with and without MFC, it calls the Windows API only directly, not <I>via</I> MFC.  However, if you use MFC (either as a static library or as a DLL), Visual C++ does not automatically link the import library, <font face="courier new">user32.lib</font>. You have to explicitly do this yourself: The line, <font face="Courier new">Project / (Configuration) Settings / Linker / Input / Object and Library Modules</font> must contain <font face="courier new">user32.lib</font>. Otherwise you would get the linker error "error LNK2001: Unresolved external symbol __imp__MessageBoxA@??".<BR>&nbsp;
<P>In order to profit from the CUDA-enhanced <i>OptiVec</i> library, do the following things:
<OL><LI>In addition to the <i>OptiVec</i> base library selected above, include the base import library OVVCCU32.lib (32-bit) or OVVCCU64.lib (64-bit).
<LI>Make sure the corresponding DLL, OVVCCU32.DLL or OVVCCU64.DLL is either in the same directory as the executable you are about to create, or in another directory contained in the Windows environment variable PATH.
<LI>Include the processor-specific OptiVec library, ending with the letter "C", e.g. OVVC8C.LIB or OVVC64_8C.lib. 
</OL><br>&nbsp;

<LI><U>Delphi:</U><BR>
The choice between the various <i>OptiVec</i> libraries is made through the selection of the unit search path. The Shareware version comes with two sets of units, one in the directory LIB4D, the other in LIB8M.
<BR>In the registered version, you have the following choices:
<table border width="100%">
<tr valign="top"><td>Processor</td><td>General-purpose</td><td>Debug</td><td>Autothreading (Multi-Processor)</td><td>MP + CUDA</td><TD>64-bit General</TD><TD>64-bit Debug</TD><TD>64-bit Multi-Proc.</TD><TD>64-bit MP+CUDA</TD></tr>
<tr valign="top"><td>P8: AMD64xxx, Core2xxx</td><td>LIB8</td><td> ---- </td><td>LIB8M</td><td>LIB8C</td><td>Win64\LIB8</td><td>Win64\LIB8D</td><td>Win64\LIB8M</td><td>Win64\LIB8C</td></tr>
<tr valign="top"><td>P4: FPU accuracy, 486DX/Pentium</td><td>LIB4</td><td>LIB4D</td><td>LIB4M</td><td> ---- </td><td> ---- </td><td> ---- </td><td> ---- </td><td> ---- </td></tr>
</table>&nbsp;<BR>
In order to profit from the CUDA-enhanced <i>OptiVec</i> library, make sure OVDCU32.DLL or OVDCU64.DLL is either in the same directory as the executable you are about to create, or in another directory contained in the Windows environment variable PATH.

<LI><U>Lazarus:</U><BR>
Just as for Delphi, the choice between the various <i>OptiVec</i> libraries is made through the selection of the "Other Units" search path. The Shareware version comes with two sets of units, one in the directory LIB8, the other in LIB9M.
<BR>In the registered version, you have the following choices:
<table border width="100%">
<tr valign="top"><td>Processor</td><td>General-purpose</td><td>Debug</td><td>Autothreading (Multi-Processor)</td><td>MP + CUDA</td></tr>
<tr valign="top"><td>P9: Haswell+ / Excavator+</td><td>LIB9</td><td> --- </td><td>LIB9M</td><td>LIB9C</td></tr>
<tr valign="top"><td>P8: AMD64xxx, Core2xxx</td><td>LIB8</td><td>LIB8D</td><td>LIB8M</td><td>LIB8C</td></tr>
</table>&nbsp;<BR>
In order to profit from the CUDA-enhanced <i>OptiVec</i> library, make sure OVDCU64.DLL is either in the same directory as the executable you are about to create, or in another directory contained in the Windows environment variable PATH.
</OL><BR>&nbsp;
<LI>Declare the use of <I>OptiVec</I> functions in your program:
<UL><LI><U>C/C++:</U><BR>
Use #include directives to include the header files described in <a href="#chap7">chapter 7.</a>
<BR>To get the whole <I>OptiVec</I> library at once, along with its new object-oriented interface, declare
<BR><font face="courier new"> #include &lt;OptiVec.h&gt;</font>
<BR>To get only all vector functions (without the object-oriented interface),<BR>
<font face="courier new"> #include &lt;VecAll.h&gt;</font>
<BR>To add all data-fitting and matrix functions to that,
<BR><font face="courier new"> #include &lt;MatAll.h&gt;.</font>
<BR>If you are writing MFC or (very old) Borland C++ ObjectWindows applications, any <I>OptiVec</I> header files should be included after the MFC or OWL header files.
<LI><U>Delphi:</U><BR>
Declare the use of <I>OptiVec</I> units as usual with the &quot;uses&quot; statement. The <I>OptiVec</I> units are grouped according to the data type. See <a href="#chap7">chapter 7.</a> In Delphi, <I>OptiVec</I> units should always be used together with the <font face="courier new">WinProcs</font> unit, as some data types are borrowed from it.
</UL><BR>&nbsp;
<LI>Have a look into the sample programs:
<UL><LI>Microsoft Visual C++:
<BR>Depending on the Visual Studio version: VDEMO_VS2015.sln,  VDEMO_VS2013.sln and so on.
<BR>Depending on the exact version, Visual Studio may have to convert this project map and its parts into a newer format. When prompted, answer "Yes to all" to accept this automatic conversion.
<LI>Embarcadero / Borland C++:
<BR>XE3 or higher: Open the project group VDEMO.groupproj (32-bit) or VDEMO64.groupproj (64-bit)
<BR>VDEMO.cbproj, &nbsp; FITDEMO.cbproj, &nbsp;MANDEL.cbproj are projects for RAD Studio 2009, 2010, XE, XE2
<BR>The *.bdsproj projects are for BDS 2006 and 2007
 <BR>VDEMOB6.BPR,  FITDEMOB6.BPR, and MANDELB6.BPR are for BC++ Builder 6+.
<LI>Delphi:
<BR>Delphi 2009, 2010, XE series, 10:  open VDEMO.dproj, FITDEMO.dproj, or  MANDEL.dproj
<BR>Delphi 2005, 2006, 2007:  open the corresponding *.bdsproj  projects
<BR>all older Delphi versions:  open the *.DPR  files.
</UL>
</OL>
After these preparations, all <I>OptiVec</I> functions are available for your programs.
<BR>Should you wish to remove <I>OptiVec</I> from your computer, please run UNINSTAL.EXE or simply delete the directory <font face="courier new">OPTIVEC</font> with its subdirectories.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2"></a>
<HR width="100%"><H1>2. Elements of <I>OptiVec</I> Routines</H1>
<P><a name="chap2_1"></a>
<H2>2.1 Synonyms for Some Data Types</H2>
To increase the versatility and completeness of <I>OptiVec</I>, additional data types are defined in &lt;VecLib.h&gt; or the unit VecLib:
<h3>a) C/C++ only:</h3>
The data type <B>ui</B> (short for &quot;unsigned index&quot;) is used for the indexing of vectors and is defined as &quot;unsigned int&quot;. 
<P>The 64-bit integer data type (<b>__int64</b> in BC++ Builder and MS Visual C++, <b>Int64</b> in Delphi) is called <b>quad</b> (for "quadword integer") in <i>OptiVec</i>. 
<BR>In 32-bit, the type <B>quad</B> is always signed. Functions for unsigned 64-bit integers are available only in the 64-bit versions of <i>OptiVec</i>.
<UL><LI><u>Borland C++ below C++ Builder 2006 only:</u> For the older BC versions, which did not directly support 64-bit integers, the data type <b>quad</b> is implemented as a struct of two 32-bit values. Floating-point numbers (preferably long doubles with their 64-bit mantissa) have to be used as intermediates. The necessary interface functions are <I><a href="FUNCREF.HTM#setquad">setquad</a>, <a href="FUNCREF.HTM#quadtod">quadtod</a></I> and <I><a href="FUNCREF.HTM#quadtod">_quadtold</a></I>. Alternatively, the two 32-bit halves may explicitly be set, as in:
<BR>xq.Hi = 0x00000001UL;
<BR>xq.Lo = 0x2468ABCDUL;</UL>
<P>The data type <B>extended</B>, which is familiar to Pascal/Delphi programmers, is defined as a synonym for &quot;long double&quot; in <I>OptiVec</I> for C/C++. As all 64-bit compilers (Visual C++ even not for 32-bit) do not support 80-bit reals, we define &quot;extended&quot; as &quot;double&quot; in the <I>OptiVec</I> versions for these compilers.
<BR>The reason for the choice of the name &quot;extended&quot; is that all <I>OptiVec</I> routines shall have identical names in C/C++ and Pascal/Delphi languages. Since the function prefixes are derived from the data types of the processed vectors (see below), this necessitates the definition of alias names for some data types denoted differently in the various languages. While the letter &quot;L&quot; (which could possibly stand for &quot;long double&quot;) is already overcrowded by the data types long int and unsigned long, the letter &quot;E&quot; is unique to the data type extended and therefore used in the prefixes for vectors and functions of long double precision. This way, the letters defining the real- number data types are in alphabetical proximity: &quot;D&quot; for double, &quot;E&quot; for extended, and &quot;F&quot; for float. Maybe the future will bring high-precision 128-bit and 256-bit real numbers which could find their place in this series as &quot;G&quot; for &quot;great&quot; and &quot;H&quot; for &quot;hyper&quot;.

<h3>b) Pascal/Delphi only:</h3>
The data type Float, which is familiar to C/C++ programmers, is defined as a synonym for Single. We prefer to have the letters defining the real-number data types in alphabetical proximity: "D" for Double, "E" for Extended, and "F" for Float. As noted above, possible future 128-bit and 256-bit real numbers could find their place in this series as "G" for Great and "H" for Hyper. 
<P>For historical reasons (dating back to the development of Turbo Pascal), the various integer data types have a somewhat confusing nomenclature in Delphi. In order to make the derived function prefixes compatible with the C/C++ versions of <I>OptiVec</I>, we define a number of synonyms, as described in the following table:

<table border width="100%">
<tr><td>type</td><td>Delphi name</td><td>synonym</td><td>derived prefix</td></tr>
<tr><td>8 bit signed</td><td>ShortInt</td><td>ByteInt</td><td>VBI_</td></tr>
<tr><td>8 bit unsigned</td><td>Byte</td><td>UByte</td><td>VUB_</td></tr>
<tr><td>16 bit signed </td><td>SmallInt</td><td>&nbsp;</TD><td>VSI_</td></tr>
<tr><td>16 bit unsigned </td><td>Word</td><td>USmall</td><td>VUS_</td></tr>
<tr><td>32 bit signed </td><td>LongInt</td><td>&nbsp;</TD><td>VLI_</td></tr>
<tr><td>32 bit unsigned </td><td>&nbsp;</TD><td>ULong</td><td>VUL_</td></tr>
<tr><td>64 bit signed </td><td>Int64</td><td>QuadInt</td><td>VQI_</td></tr>
<tr><td>64 bit unsigned (x64 version only!)</td><td>UInt64</td><td>UQuad</td><td>VUQ_</td></tr>
<tr><td>16/32 bit signed</td><td>Integer</td><td>&nbsp;</TD><td>VI_</td></tr>
<tr><td>16/32 bit unsigned</td><td>Cardinal</td><td>UInt</td><td>VU_</td></tr>
</table>

<P>To have a Boolean data type available which is of the same size as Integer, we define the type <B>IntBool</B>. It is equivalent to <B>WordBool</B> in Pascal, but <B>LongBool</B> in Delphi. You will see the <B>IntBool</B> type as the return value of many mathematical <I>VectorLib</I> functions. 
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<a name="chap2_2"></a>
<H2>2.2 Complex Numbers:
<BR>The Data Types fComplex, dComplex, eComplex, fPolar, dPolar, and ePolar</H2>
Complex numbers are treated in C/C++ in quite a confusing way. ANSI C offers only a struct complex, Borland's C/C++ compiler additionally a struct _complexl for complex numbers of double and long double precision, resp. The real and imaginary parts are denoted as x and y. 
<BR>From early versions on, Borland C++ has also offered a class complex which is of double precision; the real and imaginary parts are accessible via the functions real and imag. There is also a number of mathematical functions
available for this class.
<BR>Finally, the Standard C++ library, included from Borland C++ 5 and Visual C++ 6 on, offers the classes complex&lt;float&gt;, complex&lt;double&gt;, and complex&lt;long double&gt;, equipped with basic functionality and the same range of mathematical functions as offered by the class complex.
<BR>Later versions of Delphi offer a unit Complex which treats complex number as variant types &#x2013; with all the inefficiencies associated with such an implementation.
<BR>Functions in polar coordinates are not available in any of these approaches.

<P>Most compilers and available libraries implement complex functions very inefficiently and inaccurately. (Just writing down the textbook formula for a complex function, like it is usually done, works fine only for a very limited range of arguments!)

<P>Our aims are
<UL><LI>to make the use of complex numbers of all three data types possible in Pascal/Delphi and C as well as in C++,
<LI>to support both cartesian and polar coordinates
<LI>to allow for the most efficient implementation of all complex operations, using assembler code instead of C++ templates,
<LI>and to introduce an easy, compact and consistent nomenclature.
</UL>
To this end, the complex math library <I>CMATH</I> was created and is included in <I>OptiVec</I>. <I>CMATH</I> is described in greater detail in the file <a href="CMATH.HTM">CMATH.HTM</a>. If you use any of the non-vectorized functions contained in <I>CMATH</I> with C/C++, you should include &lt;newcplx.h&gt; (for C++ modules) or &lt;cmath.h&gt; (for plain-C modules) before (!) any of the <I>VectorLib</I> include files.

<P><I>VectorLib</I> itself contains the necessary initialization functions of complex numbers and all vectorized forms of complex math functions. If you are using only these, you need not explicitly include <I>CMATH</I>. In this case, the following complex data types are defined in &lt;VecLib.h&gt; for C/C++:
<BR><font face="courier new"> typedef struct { float Re, Im; } fComplex;
<BR>typedef struct { double Re, Im; } dComplex;
<BR>typedef struct { extended Re, Im; } eComplex;
<BR>typedef struct { float Mag, Arg; } fPolar;
<BR>typedef struct { double Mag, Arg; } dPolar;
<BR>typedef struct { extended Mag, Arg; } ePolar;</font>
<BR>(the data type extended is used as a synonym for long double, see above.)

<P>The corresponding definitions for Pascal/Delphi are contained in the unit VecLib:<font face="courier new">
<BR>type fComplex = record Re, Im: Float; end;
<BR>type dComplex = record Re, Im: Double; end;
<BR>type eComplex = record Re, Im: Extended; end;
<BR>type fPolar = record Mag, Arg: Float; end;
<BR>type dPolar = record Mag, Arg: Double; end;
<BR>type ePolar = record Mag, Arg: Extended; end;</font>

<P>If, for example, a complex number z is declared as &quot;fComplex z;&quot;, the real and imaginary parts of z are available as z.Re and z.Im, resp. Complex numbers are initialized either by setting the constituent parts separately to the desired value, e.g.,<font face="courier new">
<BR>	z.Re = 3.0; z.Im = 5.7;
<BR>p.Mag = 4.0; p.Arg = 0.7;</font>
<BR>(of course, the assignment operator is := in Pascal/Delphi).
<BR>Alternatively, the same initialization can be accomplished by the
functions <I><a href="FUNCREF.HTM#fcplx">fcplx</a></I> or <I><a href="FUNCREF.HTM#fpolr">fpolr</a></I>:
<BR><U>C/C++:</U><font face="courier new">
<BR>z = fcplx( 3.0, 5.7 );
<BR>p = fpolr( 4.0, 0.7 );</font>
<BR><U>Pascal/Delphi:</U><font face="courier new">
<BR>fcplx( z, 3.0, 5.7 );
<BR>fpolr( p, 3.0, 5.7 );</font>

<P>For double-precision complex numbers, use <I>dcplx</I> and <I>dpolr</I>, for extended-precision complex numbers, use <I>ecplx</I> and <I>epolr</I>.
<BR>Pointers to arrays or vectors of complex numbers are declared using the data types cfVector, cdVector, and ceVector (for cartesian complex) and pfVector, pdVector, and peVector (for polar complex) described below.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<a name="chap2_3"></a>
<h2>2.3 Vectors and Arrays:
<BR>The Data Types fVector, dVector, eVector,
<BR> cfVector, cdVector, ceVector, pfVector, pdVector, peVector,
<BR> iVector, biVector, siVector, liVector, qiVector,
<BR>uVector, ubVector, usVector, ulVector, uqVector, and uiVector</h2>
We define, as usual, a &quot;vector&quot; as a one-dimensional array of data containing, at least, one element, with all elements being of the same data type. Using a more mathematical definition, a vector is a rank-one tensor. A two-dimensional array (i.e. a rank-two tensor) is denoted as a &quot;matrix&quot;, and higher dimensions are always referred to as &quot;tensors&quot;.
<BR><B>In contrast to other approaches, <I>VectorLib</I> does not allow zero-size vectors!</B><P>The basis of all <I>VectorLib</I> routines is formed by the various vector data types given below and declared in &lt;VecLib.h&gt; or the unit <i>VecLib</i>.  In contrast to the fixed-size static arrays, the <I>VectorLib</I> types use dynamic memory allocation and allow for varying sizes. Because of this increased flexibility, we recommend that you predominantly use the latter. Here they are:<BR>&nbsp;

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 WIDTH="95%">
<TR><TD ALIGN="CENTER"><font size="+1"><B>C/C++</B></font><BR>
<TABLE BORDER=0 WIDTH="97%" >
<TR><TD>typedef</td><td>float *</td><td>fVector</td></tr>
<TR><TD>typedef</td><td>double *</td><td>dVector</td></tr>
<TR><TD>typedef</td><td>extended *</td><td>eVector</td></tr>
<TR><TD>typedef</td><td>fComplex *</td><td>cfVector</td></tr>
<TR><TD>typedef</td><td>dComplex *</td><td>cdVector</td></tr>
<TR><TD>typedef</td><td>eComplex *</td><td>ceVector</td></tr>
<TR><TD>typedef</td><td>fPolar *</td><td>pfVector</td></tr>
<TR><TD>typedef</td><td>dPolar *</td><td>pdVector</td></tr>
<TR><TD>typedef</td><td>ePolar *</td><td>peVector</td></tr>
<TR><TD>typedef</td><td>int *</td><td>iVector</td></tr>
<TR><TD>typedef</td><td>byte *</td><td>biVector</td></tr>
<TR><TD>typedef</td><td>short *</td><td>siVector</td></tr>
<TR><TD>typedef</td><td>long *</td><td>liVector</td></tr>
<TR><TD>typedef</td><td>quad *</td><td>qiVector</td></tr>
<TR><TD>typedef</td><td>unsigned *</td><td>uVector</td></tr>
<TR><TD>typedef</td><td>unsigned byte *</td><td>ubVector</td></tr>
<TR><TD>typedef</td><td>unsigned short *</td><td>usVector</td></tr>
<TR><TD>typedef</td><td>unsigned long *</td><td>ulVector</td></tr>
<TR><TD>typedef</td><td>uquad *</td><td>uqVector</td></tr>
<TR><TD>typedef</td><td>ui *</td><td>uiVector</td></tr>
</TABLE>
</TD><TD>&nbsp;</TD>
<TD VALIGN="TOP" ALIGN="CENTER"><font size="+1"><B>Pascal/Delphi</B></font><BR>
<TABLE ALIGN=RIGHT BORDER=0 WIDTH="100%" >
<TR><TD>type</td><td>fVector</td><td>= ^Float;</td></tr>
<TR><TD>type</td><td>dVector</td><td>= ^Double;</td></tr>
<TR><TD>type</td><td>eVector</td><td>= ^Extended;</td></tr>
<TR><TD>type</td><td>cfVector</td><td>= ^fComplex;</td></tr>
<TR><TD>type</td><td>cdVector</td><td>= ^dComplex;</td></tr>
<TR><TD>type</td><td>ceVector</td><td>= ^eComplex;</td></tr>
<TR><TD>type</td><td>pfVector</td><td>= ^fPolar;</td></tr>
<TR><TD>type</td><td>pdVector</td><td>= ^dPolar;</td></tr>
<TR><TD>type</td><td>peVector</td><td>= ^ePolar</td></tr>
<TR><TD>type</td><td>iVector</td><td>= ^Integer;</td></tr>
<TR><TD>type</td><td>biVector</td><td>= ^ByteInt;</td></tr>
<TR><TD>type</td><td>siVector</td><td>= ^SmallInt;</td></tr>
<TR><TD>type</td><td>liVector</td><td>= ^LongInt;</td></tr>
<TR><TD>type</td><td>qiVector</td><td>= ^QuadInt;</td></tr>
<TR><TD>type</td><td>uVector</td><td>= ^UInt;</td></tr>
<TR><TD>type</td><td>ubVector</td><td>= ^UByte;</td></tr>
<TR><TD>type</td><td>usVector</td><td>= ^USmall;</td></tr>
<TR><TD>type</td><td>ulVector</td><td>= ^ULong;</td></tr>
<TR><TD>type</td><td>uqVector</td><td>= ^UQuad;</td></tr>
<TR><TD></TD><td></TD><td></TD></tr>
</table>
</TD></TR>
</TABLE>

<BR>Internally, a data type like fVector means &quot;pointer to float&quot;, but you may think of a variable declared as fVector rather in terms of a &quot;vector of floats&quot;.<BR>&nbsp;
<table width="100%"><tr><td width="10%"></TD><td>
<font size="-1"><U>Note:</U> in connection with Windows programs, often the letter &quot;l&quot; or &quot;L&quot; is used to denote &quot;long int&quot; variables. In order to prevent confusion, however, the data type &quot;long int&quot; is signalled by &quot;li&quot; or &quot;LI&quot;, and the data type &quot;unsigned long&quot; is signalled by &quot;ul&quot; or &quot;UL&quot;. Conflicts with prefixes for &quot;long double&quot; vectors are avoided by deriving these from the alias name &quot;extended&quot; and using &quot;e&quot;, &quot;ce&quot;, &quot;E&quot;, and &quot;CE&quot;, as described above and in the following.</font></td></tr></table>&nbsp;

<BR>Delphi also offers dynamically-allocated arrays, which may also be used as arguments for <I>OptiVec</I> functions. The following table compares the pointer-based vectors of <I>VectorLib</I> with the array types of Pascal/Delphi:
<BR>&nbsp;

<table border=1><tr valign="top"><td>&nbsp;</TD><td><I>OptiVec</I> vectors</td><td>Pascal/Delphi static/dynamic arrays</td></tr>
<tr valign="top"><td>alignment of first element</td><td>on 32-byte boundary for optimum cache-line matching</td><td>2 or 4-byte boundary (may cause line-break penalty for double, QuadInt)</td></tr>
<tr valign="top"><td>alignment of following elements</td><td>packed (i.e., no dummy bytes between elements, even for 10- and 20-bit types</td><td>arrays must be declared as &quot;packed&quot; for Delphi to be compatible with <I>OptiVec</I></td></tr>
<tr valign="top"><td>index range checking</td><td>Debug libraries: automatic; Release libraries: none</td><td>automatic with built-in size information</td></tr>
<tr valign="top"><td>dynamic allocation</td><td>function <a href="FUNCREF.HTM#vector">VF_vector</a>,&nbsp; <a href="FUNCREF.HTM#vector0">VF_vector0</a></td><td>procedure SetLength</td></tr>
<tr valign="top"><td>initialization with 0</td><td>optional by calling <a href="FUNCREF.HTM#vector0">VF_vector0</a></td><td>always</td></tr>
<tr valign="top"><td>de-allocation</td><td>function <a href="FUNCREF.HTM#free">V_free</a>,&nbsp; <a href="FUNCREF.HTM#freeAll">V_freeAll</a></td><td>procedure Finalize</td></tr>
<tr valign="top"><td>reading single elements</td><td>function <a href="FUNCREF.HTM#element">VF_element</a>:<BR>a := VF_element(X,5);<BR>typecast into array also possible:<BR>a := fArray(X)[5];</td><td>index in brackets:<BR>a := X[5];</td></tr>
<tr valign="top"><td>setting single elements</td><td>function <a href="#FUNCREF.HTM#setElement">VF_setElement</a>:<BR>VF_setElement(X,5, a);<BR>Delphi only: typecast into array also possible:<BR>fArray(X)[5] := a;</td><td>index in brackets:<BR>X[5] := a;</td></tr>
<tr valign="top"><td>getting the address of a single element</td><td>function <a href="#FUNCREF.HTM#Pelement">VF_Pelement</a></td><td>&nbsp;</td></tr>
<tr valign="top"><td>passing to <I>OptiVec</I> function</td><td>directly:<BR><a href="FUNCREF.HTM#equ1">VF_equ1</a>( X, sz );</td><td>address-of operator:<BR><a href="FUNKREF.HTM#equ1">VF_equ1</a>( @X, sz );</td></tr>
<tr valign="top"><td>passing sub-vector to <I>OptiVec</I> function</td><td>function <a href="#FUNCREF.HTM#Pelement">VF_Pelement</a>:<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( VF_Pelement(X,10), sz-10, 3.7);</td><td>address-of operator:<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( @X[10], sz-10, 3.7 );</td></tr>
</table>&nbsp;
<BR>Summarizing the properties of <I>OptiVec</I> vectors and of Pascal/Delphi arrays, the latter are somewhat more convenient and, due to the index range checking, safer, whereas the pointer-based <I>OptiVec</I> vectors are processed faster (due to the better alignment and to the absence of checking routines).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_4"></a>
<h2>2.4 Real-number Functions:
<BR>The Prefixes <I>VF_,&nbsp; VD_</I>, and <I>VE_</I></h2>
<I>OptiVec</I> supports the usual three floating-point data types: float, double, and extended (i.e., long double). BCD numbers are not supported.
<P>Any of the algebraic and mathematical functions included in this library exists in one variant for each floating-point format. The data type of all floating-point vector elements, parameters, and of the return value is always the same within one function. The data type is signalled by the second letter of the prefix: <I>VF_</I> denotes the variant of a function that uses exclusively the data type float (Pascal: Single), <I>VD_</I> stands for the data type double, and <I>VE_</I> for the data type extended, i.e., long double. (The first letter, &quot;V&quot;, stands for &quot;Vector function&quot;, of course.) <I>VF_</I> functions thus work on arrays declared as fVector, use parameters of the type float, and, if there is any floating-point return value, this will also be of the type float. Except for a very few cases, there are no mixed-type functions (that would, e.g., work on vectors of type fVector, use parameters of type double and return a value of type long double). 

<P>For the description of the functions in the <a href="FUNCREF.HTM#chap8">Alphabetical Reference</a>, generally only the <I>VF_</I> version is described and its syntax explicitly given. The versions for the data types double and long double
are exactly analogous to the <I>VF_</I> variant. You have only to replace the prefix <I>VF_</I> by <I>VD_</I> (or <I>VE_</I>) and to use &quot;dVector&quot; and &quot;double&quot; (or &quot;eVector&quot; and &quot;extended&quot;, resp.) wherever you find &quot;fVector&quot; and &quot;float&quot; in the <I>VF_</I> version.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_5"></a>
<h2>2.5 Complex-number Functions:
<BR>The Prefixes <I>VCF_,&nbsp; VCD_,&nbsp; VCE_,&nbsp; VPF_,&nbsp; VPD_</I>, and <I>VPE_</I></h2>
Any prefix with its second letter being &quot;C&quot; denotes a function of cartesian complex numbers. If the second letter is &quot;P&quot;, the function is for complex numbers in polar coordinates. By analogy with the nomenclature used for real-number functions, the prefix <I>VCF_</I> signals the exclusive use of single-precision vectors, parameters and return values (fComplex, cfVector and float). Similarly, <I>VCD_</I> is used for double-precision calculations, and <I>VCE_</I> for extended precision. Wherever &quot;fComplex&quot;, &quot;cfVector&quot;, and &quot;float&quot; appear in the description of a function in the <I>VCF_</I> version, the <I>VCD_</I> and <I>VCE_</I> versions are obtained by substituting with &quot;dComplex&quot;, &quot;cdVector&quot; and &quot;double&quot; or &quot;eComplex&quot;, &quot;ceVector&quot;, and &quot;extended&quot; (or &quot;long double&quot;), respectively. Likewise, the <I>VPF_,&nbsp; VPD_</I>, and <I>VPE_</I> functions work on vector elements of the types fPolar, dPolar, and ePolar, resp.
<P>Return values of the complex data types are not possible in Pascal/Delphi. Therefore, the syntax of those functions returning a complex number is different in C/C++ and Pascal/Delphi.
<P>In contrast to the carelessness with which complex mathematical functions are often treated (see above), the complex functions of <I>OptiVec</I> are designed in such a way as to achieve full accuracy over the complete range of input/output values possible with the respective data type.
<P>In order to perform non-vectorized complex operations with the same level of speed and reliability as the vectorized ones, use <I>CMATH</I>. See <a href="CMATH.HTM">CMATH.HTM</a> for details.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_6"></a>
<h2>2.6 Functions of the Integer Data Types:
<BR>The Prefixes <I>VI_,&nbsp; VBI_,&nbsp; VSI_,&nbsp; VLI_,&nbsp; VQI_</I>,<BR>
<I>VU_,&nbsp; VUB_,&nbsp; VUS_,&nbsp; VUL_, &nbsp;VUQ_</I>, and <I>VUI_</I></h2>
The nomenclature for the integer data types is designed in a similar way as for the floating-point data types:
<BR>prefix VBI_: data type char (or byte) / ByteInt,
<BR>prefix VSI_: data type short int / SmallInt, 
<BR>prefix VI_: data type int / Integer,
<BR>prefix VLI_: data type long int / LongInt, 
<BR>prefix VQI_: data type quad / QuadInt.
<P>F&uuml;r die vorzeichenlosen Ganzzahl-Typen gilt analog:
<BR>prefix VUB_: data type unsigned char (unsigned byte) / UByte,
<BR>prefix VUS_: data type unsigned short / USmall,
<BR>prefix VU_: data type unsigned / UInt,
<BR>prefix VUL_: data type unsigned long / ULong,
<BR>prefix VUQ_: data type uquad / UQuad (only for Win64),
<BR>prefix VUI_: data type ui.

<P>Don't be afraid of so many data types. It is one of the advantages of modern computer languages to have them, and it is one of the disadvantages, at the same time, that a programming style is supported which mixes all the data types until it is no longer clear &quot;who is who&quot;. In all normal cases, the <I>VI_,&nbsp; VLI_</I>, and <I>VU_</I> functions should be sufficient; but keep in mind that there are more available in case you need them.
<P>If present, the vectorized integer functions are always described together with their floating-point analogues. To obtain, for example, the <I>VI_</I> version, vectors of type iVector have to be substituted for those of type fVector which are demanded by the <I>VF_</I> version. In the same way, the other versions are obtained by changing &quot;float&quot; and &quot;fVector&quot; into the desired data type.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_7"></a>
<H2>2.7 Common Functions of Several Data Types: The Prefix <I>V_</I></H2>
Several functions exist that are either used independently of any data type or that are used to interconvert the data types. Functions like <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> and <I><a href="FUNCREF.HTM#free">V_free</a></I> belong to the first case (you have to initialize the plotting routines regardless of the data type of the vectors you are going to plot, and the initialization is not specific for any data type).
<BR>A function like <I><a href="FUNCREF.HTM#ItoF">V_ULtoD</a></I> belongs to the second case; here, a ulVector
(a vector whose elements are of the data type unsigned long) is transformed into a dVector (a vector whose elements are doubles).
<BR>The type-independent functions are declared in &lt;VecLib.h&gt; and &lt;Vgraph.h&gt; or the units VecLib and Vgraph, respectively. The data-type interconversion functions are declared in the include-files or units belonging to the destination type (i.e. the type into which the numbers are converted).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap3"></a>
<HR width="100%"><H1>3. <I>VecObj</I>, theObject-Oriented Interface for <I>VectorLib</I></H1>
<I>VecObj</I>, the object-oriented C++ interface to <I>OptiVec</I> vector functions was written by Brian Dale, Case Western Reserve University. <a href="MATRIX.HTM#chap1_3_1"><I>MatObj</I>, the extension for matrices</a>, is now included as well.
<BR>Among the advantages <I>VecObj</I> offers are the following:
<UL><LI>automatic allocation and deallocation of memory
<LI>simplified vector handling
<LI>greatly reduced risk of memory leaks
<LI>increased memory access safety
<LI>intuitive overloaded operators
<LI>simpler function calls
</UL>
There are a few draw-backs, though, which you should be aware of:
<UL><LI>increased compiler load
<LI>larger overhead (as for any encapsulated C++ code!), leading to 
<LI>increased code size
<LI>decreased computational efficiency
<LI>vectors can be processed only as a whole, not in parts
</UL>
<I>VecObj</I> is contained in the include-files &lt;VecObj.h&gt;, &lt;fVecObj.h&gt;, &lt;dVecObj.h&gt; etc., with one include-file for each of the data-types supported in <I>OptiVec</I>.
<BR>To get the whole interface (for all data types at once),
<BR><font face="courier new">#include &lt;OptiVec.h&gt;.</font>
<BR>For access to any of the vector graphics functions, always include &lt;OptiVec.h&gt;.
<P><U>MS Visual C++ and Embarcadero / Borland C++ Builder</U> (but not previous Borland C++ versions): Programmers should put the directive
<BR><font face="courier new">&quot;using namespace OptiVec;&quot;</font>
<BR>either in the body of any function that uses<I>tVecObj</I>, or in the global declaration part of the program.  Placing the directive in the function body is safer, avoiding potential namespace conflicts in other functions.
<BR>The vector objects are defined as classes vector&lt;T&gt;, encapsulating the vector address (pointer) and size.
<BR>For easier use, these classes got alias names fVecObj, dVecObj, and so on, with the data-type signalled by the first one or two letters of the class name, in the same way as the vector types described above.
<P>All functions defined in <I>VectorLib</I> for a specific vector data-type are contained as member functions in the respective tVecObj class.
<BR>The constructors are available in four forms:
<BR>vector(); // no memory allocated, size set to 0
<BR>vector( ui size ); // vector of size elements allocated
<BR>vector( ui size, T fill ); // as before, but initialized with value &quot;fill&quot;
<BR>vector( vector&lt;T&gt; init ); // creates a copy of the vector &quot;init&quot;

<P>For all vector classes, the arithmetic operators
<BR>+&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;&nbsp;&nbsp;&nbsp;*=&nbsp;&nbsp;&nbsp;&nbsp;/=
<BR>are defined, with the exception of the polar-complex vector classes, where only multiplications and divisions, but no additions or subtractions are supported. These operators are the only cases in which you can directly assign the result of a calculation to a vector object, like<BR><font face="courier new">fVecObj Z = X + Y;</font> or<BR>
<font face="courier new">fVecObj Z = X * 3.5;</font><BR>
Note, however, that the C++ class syntax rules do not allow a very efficient implementation of these operators. The arithmetic member functions are much faster. If speed is an issue, use<BR>
<font face="courier new">fVecObj Z.addV( X, Y );</font> or<BR>
<font face="courier new">fVecObj Z.mulC( X, 3.5 );</font><BR>
 instead of the operator syntax. 
<BR><B>The operator * refers to element-wise multiplication, <U>not</U> to the scalar product of two vectors.</B>

<P>All other arithmetic and math functions can only be called as member functions of the respective output vector as, for example, <font face="courier new">Y.exp(X)</font>. Although it would certainly be more logical to have these functions defined in such a way that you could write &quot;<font face="courier new">Y = exp(X)</font>&quot; instead, the member-function syntax was chosen for efficiency considerations: The only way to implement the second variant is to store the result of the exponential function of X first in a temporary vector, which is then copied into Y, thus considerably increasing the work-load and memory demands.
<P>While most <I>VecObj</I> functions are member functions of the <U>output</U> vector, there exists a number of functions which do not have an output vector. In these cases, the functions are member functions of an input vector.<BR>
Example: <font face="courier new">s = X.mean();</font>.

<P>If you ever need to process a <I>VecObj</I> vector in a &quot;classic&quot; plain-C <I>VectorLib</I> function (for example, to process only some part of it), you may use the member functions <BR>
<I>getSize()</I> to retrieve its size, <BR>
<I>getVector()</I> for the pointer (of data type tVector, where "t" stands for the usual type prefix), and<BR>
<I>Pelement( n )</I> for a pointer to the to the <I>n</I>'th element.

<P>The syntax of all <I>VecObj</I> functions is described in <a href="FUNCREF.HTM">FUNCREF.HTM</a> together with
the basic <I>VectorLib</I> functions for which <I>tVecObj</I> serves as a wrapper.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4"></a>
<HR width="100%"><H1>4. <I>VectorLib</I> Functions and Routines: A Short Overview</H1>

<P><a name="chap4_1"></a>
<H2>4.1 Generation, Initialization and De-Allocation of Vectors</H2>
<BR>With <I>VectorLib</I>, you may use static arrays (like, for example, float a[100];) as well as dynamically allocated ones (see <a href="#chap2_3">chapter 2.3</a>). We recommend, however, that you use the more flexible vector types defined by <I>VectorLib</I>, using dynamic allocation.
<P>The following functions manage dynamically allocated vectors:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#vector">VF_vector</a></TD><TD>memory allocation for one vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#vector0">VF_vector0</a></TD><TD>memory allocation and initialization of all elements with 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#free">V_free</a></TD><TD>free one vector</TD></TR>
<TR><TD> <a href="FUNCREF.HTM#nfree">V_nfree</a></TD><TD> free n vectors (only for C, not for Pascal)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#freeAll">V_freeAll</a></TD><TD>free all existing vectors</TD></TR>
</TABLE>&nbsp;
<BR>You should always take proper care to de-allocate the memory of vectors which are no longer needed. Internally, the allocated vectors are written into a table to keep track of the allocated memory. If you try to free a vector that has never been or is no longer allocated, you get a warning message, and nothing is freed.
<BR>You might wonder why we add still more memory allocation functions to the already rich <I>omnium gatherum</I> of C/C++ and Pascal/Delphi. The reason is that, for every environment and every memory model, the most appropriate memory management functions shall be selected automatically. This means that you, the user, need not deal yourself with the various methods, but can leave this task to <I>OptiVec</I>. Moreover, this makes your programs more easily portable. 
<H4>Performance tips:</H4>
<UL><LI>The vectors allocated by <a href="FUNCREF.HTM#vector">VF_vector</a> etc. are aligned on 64 byte boundaries for optimum cache-line matching (Intel Pentium XX: 32 byte, AMD Athlon: 64 byte). On the other hand, static arrays as well as vectors created by the operator <B>new</B> or by the standard functions, <I>malloc, calloc, GetMem, LocalAlloc, GlobalAlloc</I> etc. are aligned on 4 byte boundaries only. Consequently, for optimum performance, you should use only vectors allocated by <I>VF_vector</I> etc.
<LI>The SIMD commands employed in the P6 version require data to be aligned on 16 byte boundaries.  Again the same advice holds: Use the dynamic vectors of <I>OptiVec</I> to guarantee the necessary alignment. The penalty for not properly aligned data may amount to 25%.
<LI>Instead of many small vectors, consider allocating one large vector. Define the small vectors as parts of the larger one:<BR>
<table width="90%">
<tr valign="TOP"><td width="50%"><font face="courier new"><U>C/C++:</U><BR>
X = VF_vector( 3*size);<BR>
Z = (Y = X+size) + size;</font></td>
<td width="50%"><font face="courier new"><U>Pascal/Delphi:</U><BR>
X := VF_vector( 3*size );<BR>
Y := VF_Pelement( X, size );<BR>
Z := VF_Pelement( Y, size );</font></td>
</tr></table>
Be sure size is rounded up so as to make size*sizeof(&nbsp;data&nbsp;type&nbsp;) a multiple of 32 or 64.
<LI>Avoid frequent allocation and deallocation. Try to re-use vectors instead.
</UL>

<P>The following functions are used to initialize or re-initialize vectors that have already been created:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#equ0">VF_equ0</a></TD><TD>set all elements of a vector equal to 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equ1">VF_equ1</a></TD><TD>set all elements equal to 1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equm1">VF_equm1</a></TD><TD>set all elements equal to -1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equC">VF_equC</a></TD><TD>set all elements equal to a constant C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equV">VF_equV</a></TD><TD>make one vector a copy of another</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equV">VFx_equV</a></TD><TD>"expanded" version of the equality operation: Y<SUB>i</SUB> = a * X<SUB>i</SUB> + b</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ramp">VF_ramp</a></TD><TD>"ramp": X<SUB>i</SUB> = a * i + b.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#randomLC">VF_randomLC</a></TD><TD>high-quality random numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#random">VF_random</a></TD><TD>simplified form of <a href="FUNCREF.HTM#random">VF_randomLC</a> for high-quality random numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#noiseLC">VF_noiseLC</a></TD><TD>white noise</TD></TR>
<TR><TD><a href="FUNCREF.HTM#noise">VF_noise</a></TD><TD>simplified form of <a href="FUNCREF.HTM#noiseLC">VF_noiseLC</a> fo white noise</TD></TR>
<TR><TD><a href="FUNCREF.HTM#comb">VF_comb</a></TD><TD>"comb": equals a constant C at equidistant points, elsewhere 0</TD></TR>
</TABLE>&nbsp;
<BR>The following functions generate windows for use in spectral analysis:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#Hann">VF_Hann</a></TD><TD>Hann window</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Parzen">VF_Parzen</a></TD><TD>Parzen window</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Welch">VF_Welch</a></TD><TD>Welch window</TD></TR>
</TABLE>&nbsp;

<BR>Complex vectors may be initialized by these functions:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#ReImtoC">VF_ReImtoC</a></TD><TD>merge two vectors, <I>Re</I> and <I>Im</I>, into one cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#RetoC">VF_RetoC</a></TD><TD>overwrite the real part of a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ImtoC">VF_ImtoC</a></TD><TD>overwrite the imaginary part of a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PolartoC">VF_PolartoC</a></TD><TD>construct a cartesian complex vector from polar coordinates, entered as separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoP">VF_MagArgtoP</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector, reducing the <I>Arg</I> range to the principal value, -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagtoP">VF_MagtoP</a></TD><TD>overwrite the <I>Mag</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ArgtoP">VF_ArgtoP</a></TD><TD>overwrite the <I>Arg</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ReImtoP">VF_ReImtoP</a></TD><TD>construct a polar complex vector from cartesian coordinates, entered as separate vectors <I>Re</I> and <I>Im</I></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_2"></a>
<H2>4.2 Index-oriented Manipulations</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#rev">VF_rev</a></TD><TD>reverse the element ordering</TD></TR>
<TR><TD><a href="FUNCREF.HTM#reflect">VF_reflect</a></TD><TD>set the upper half of a vector equal to the reversed lower half</TD></TR>
<TR><TD><a href="FUNCREF.HTM#rotate">VF_rotate</a></TD><TD>rotate the ordering of the elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#rotate_buf">VF_rotate_buf</a></TD><TD>efficient rotation, employing user-specified buffer memory</TD></TR>
<TR><TD><a href="FUNCREF.HTM#insert">VF_insert</a></TD><TD>insert one element into a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#delete">VF_delete</a></TD><TD>delete one element from a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sort">VF_sort</a></TD><TD>fast sorting of the elements (ascending or descending order)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sortind">VF_sortind</a></TD><TD>sorting of an index array associated with a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector">VF_subvector</a></TD><TD>extract a subvector from a (normally larger) vector, using a constant sampling interval.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#indpick">VF_indpick</a></TD><TD>fills a vector with elements &quot;picked&quot; from another vector according to their indices.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#indput">VF_indput</a></TD><TD>distribute the elements of one vector to the sites of another vector specified by their indices.</TD></TR>
</TABLE>&nbsp;
<BR>Operations performed only on a sampled sub-set of elements of a vector are provided by the <I><a href="FUNCREF.HTM#subvector_">VF_subvector_...</a></I> family, where the omission mark stands for a suffix denoting the desired operation:&nbsp;

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><TABLE BORDER WIDTH="97%" >
<TR><TD><a href="FUNCREF.HTM#subvector_equC">VF_subvector_equC</a></TD>
<TD>X<sub>i*samp</sub>  =  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_addC</a></TD>
<TD>X<sub>i*samp</sub>  +=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subC</a></TD>
<TD>X<sub>i*samp</sub>  -=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subrC</a></TD>
<TD>X<sub>i*samp</sub>  =  C - X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_mulC</a></TD>
<TD>X<sub>i*samp</sub>  *=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divC</a></TD>
<TD>X<sub>i*samp</sub>  /=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divrC</a></TD>
<TD>X<sub>i*samp</sub>  =  C / X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
</TABLE>
</TD>
<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD><a href="FUNCREF.HTM#subvector_equV">VF_subvector_equV</a></TD>
<TD>Y<sub>i*samp</sub>  =  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_addV</a></TD>
<TD>X<sub>i*samp</sub>  +=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subV</a></TD>
<TD>X<sub>i*samp</sub>  -=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subrV</a></TD>
<TD>X<sub>i*samp</sub>  =  Y<sub>i</sub> - X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_mulV</a></TD>
<TD>X<sub>i*samp</sub>  *=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divV</a></TD>
<TD>X<sub>i*samp</sub>  /=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divrV</a></TD>
<TD>X<sub>i*samp</sub>  =  Y<sub>i</sub> / X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>&nbsp;

<BR>Searching tables for specific values is accomplished by: 
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#searchC">VF_searchC</a></TD>
<TD>search for the element of a vector that is closest to a pre-set value C (closest, closest larger-or-equal, or closest smaller-or-equal value, depending on a parameter <I>"mode"</I>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#searchV">VF_searchV</a></TD><TD>the same, but for a whole array of pre-set values</TD></TR>
</TABLE>&nbsp;

<BR>Interpolations are performed by:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#polyinterpol">VF_polyinterpol</a></TD><TD>polynomial interpolation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ratinterpol">VF_ratinterpol</a></TD><TD>rational interpolation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#natCubSplineInterpol">VF_natCubSplineInterpol</a></TD><TD>natural cubic spline interpolation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#splineinterpol">VF_splineinterpol</a></TD><TD>general cubic spline interpolation</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_3"></a>
<H2>4.3 Data-Type Interconversions</H2>
The first thing that has to be said about the floating-point data-type interconversions is: do not use them too extensively. Decide which accuracy is appropriate for your application, and then use consistently either the <I>VF_</I>, or the <I>VD_</I>, or the <I>VE_</I> version of the functions you need. Nevertheless, every data type can be converted into every other, in case it is necessary. Only a few examples are given; the rest should be obvious:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#FtoD">V_FtoD</a></TD><TD><B>float</B> to <B>double</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#FtoD">V_CDtoCF</a></TD><TD><B>complex&lt;double&gt;</B> to <B>complex&lt;float&gt;</B> (with overflow protection)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FtoD">V_PFtoPE</a></TD><TD><B>polar&lt;float&gt;</B> to <B>polar&lt;extended&gt;</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoC">VF_PtoC</a></TD><TD><B>polar&lt;float&gt;</B> to <B>complex&lt;float&gt;</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ItoLI</a></TD><TD><B>int</B> to <B>long int</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ULtoUS</a></TD><TD><B>unsigned long</B> to <B>unsigned short</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ItoU</a></TD><TD><B>signed int</B> to <B>unsigned int</B>. Interconversions between signed and unsigned types can only be performed on the same level of accuracy. Functions like &quot;V_UStoLI&quot; do <U>not</U> exist.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoF">V_ItoF</a></TD><TD><B>int</B> to <B>float</B></TD></TR>
</TABLE>&nbsp;

<BR>The conversion of floating-point numbers into integers is performed by the following functions, differing in the way a possible fractional part is treated:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_roundtoI</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_choptoI</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunctoI</a></TD><TD>the same as <a href="FUNCREF.HTM#choptoI">VF_choptoI</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoI</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoI</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>&nbsp;
<BR>These operations are treated as mathematical functions and are further described in <a href="#chap4_6_1">chapter 4.6.1</a>.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_4"></a>
<H2>4.4 More about Integer Arithmetics</H2>
Although the rules of integer arithmetics are quite straightforward, it appears appropriate to recall that all integer operations are implicitly performed modulo 2<sup>n</sup>, where n is the number of bits the numbers are represented with. This means that any result, falling outside the range of the respective data type, is made to fall inside the range by loosing the highest bits. The effect is the same as if as many times 2<sup>n</sup> had been added to (or subtracted from) the &quot;correct&quot; result as necessary to reach the legal range.
<BR>For example, in the data type <B>short</B> / <B>SmallInt</B>, the result of the multiplication 5 * 20000 is -31072. The reason for this seemingly wrong negative result is that the &quot;correct&quot; result, 100000, falls outside the range of <B>short</B> numbers which is -32768 &lt;= x &lt;= +32767. <B>short</B> / <B>SmallInt</B> is a 16-bit type, so n = 16, and 2<sup>n</sup> = 65536. In order to make the result fall into the specified range, the processor &quot;subtracts&quot; 2 * 65536 = 131072 from 100000, yielding -31072.

<BR>Note that overflowing intermediate results cannot be &quot;cured&quot; by any following operation. For example, (5 * 20000) / 4 is not (as one might hope) 25000, but rather -7768.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_5"></a>
<H2>4.5 Basic Functions of Complex Vectors</H2>
The following functions are available for the basic treatment of <U>cartesian complex</U> vectors:&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#ReImtoC">VF_ReImtoC</a></TD><TD>form a cartesian complex vector out of its real and imaginary parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#RetoC">VF_RetoC</a></TD><TD>overwrite the real part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ImtoC">VF_ImtoC</a></TD><TD>overwrite the imaginary part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoReIm">VF_CtoReIm</a></TD><TD>extract the real and imaginary parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoRe">VF_CtoRe</a></TD><TD>extract the real part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoIm">VF_CtoIm</a></TD><TD>extract the imaginary part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PolartoC">VF_PolartoC</a></TD><TD>form a cartesian complex vector out of polar coordinates, entered as separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoPolar">VF_CtoPolar</a></TD><TD>transform cartesian complex into polar coordinates, returned in the separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoAbs">VF_CtoAbs</a></TD><TD>absolute value (magnitude of the pointer in the complex plane)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoArg">VF_CtoArg</a></TD><TD>argument (angle of the pointer in the complex plane)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoNorm">VF_CtoNorm</a></TD><TD>norm (here defined as the square of the absolute value)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#norm">VCF_normtoC</a></TD><TD>norm, stored as a cartesian complex vector (with all imaginary parts equal to 0)</TD></TR>
</TABLE>&nbsp;

<BR>The corresponding functions for <U>polar coordinates</U> are:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#MagArgtoP">VF_MagArgtoP</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector, reducing the <I>Arg</I> range to the principal value, -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagtoP">VF_MagtoP</a></TD><TD>overwrite the <I>Mag</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ArgtoP">VF_ArgtoP</a></TD><TD>overwrite the <I>Arg</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoMagArg">VF_PtoMagArg</a></TD><TD>extract the <I>Mag</I> and <I>Arg</I> parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoMag">VF_PtoMag</a></TD><TD>extract the <I>Mag</I> part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoArg">VF_PtoArg</a></TD><TD>extract the <I>Arg</I> part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoNorm">VF_PtoNorm</a></TD><TD>norm (here defined as the square of the magnitude)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ReImtoP">VF_ReImtoP</a></TD><TD>construct a polar complex vector from cartesian coordinates, entered as separate vectors <I>Re</I> and <I>Im</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoReIm">VF_PtoReIm</a></TD><TD>transform a polar complex vector into two real vectors, representing the corresponding cartesian coordinates <I>Re</I> and <I>Im</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoRe">VF_PtoRe</a></TD><TD>calculate the real part of the polar complex input numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoIm">VF_PtoIm</a></TD><TD>calculate the imaginary part of the polar complex input numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#principal">VPF_principal</a></TD><TD>calculate the principal value. You might recall that each complex number has an infinite number of representations in polar coordinates, with the angles differing by an integer
multiple of 2 <font face="symbol">p</font>. The representation with -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font> is called the principal value.</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6"></a>
<H2>4.6 Mathematical Functions</H2>
Lacking a more well-founded definition, we denote as &quot;mathematical&quot; all those functions which calculate each single element of a vector from the corresponding element of another vector by a more or less simple mathematical formula:<BR>Y<sub>i</sub> = f( X<sub>i</sub> ). 
<BR>Except for the &quot;basic arithmetics&quot; functions, they are defined only for the floating-point data types. Most of these mathematical functions are vectorized versions of scalar ANSI C or Pascal functions or derived from them. In C/C++, errors are handled by <I>_matherr</I> and <I>_matherrl</I>. In Pascal/Delphi, <I>OptiVec</I> allows the user to control error handling by means of the function <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>. 
<P>In addition to this error handling &quot;by element&quot;, the return values of the <I>VectorLib</I> math functions show if all elements have been processed successfully. In C/C++, the return value is of the data-type <B>int</B>, in Pascal/Delphi, it is <B>IntBool</B>. (We do not yet use the newly introduced data type bool for this return value in C/C++, in order to make <I>VectorLib</I> compatible also with older versions of C compilers.) If a math function worked error-free, the return value is FALSE (0), otherwise it is TRUE (any non-zero number).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6_1"></a>
<H2>4.6.1 Rounding</H2>
Some of the functions converting floating-point into integer vectors have already been noted above. The result of these rounding operations may either be left in the original floating-point format, or it may be converted into one of the integer types. The following functions store the result in the original floating-point format:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_round</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_chop</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunc</a></TD><TD>the same as <a href="FUNCREF.HTM#chop">VF_chop</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceil</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floor</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>
&nbsp;
<BR>The following functions store the result as integers (type <B>int / Integer</B>):&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_roundtoI</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_choptoI</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunctoI</a></TD><TD>the same as <a href="FUNCREF.HTM#chop">VF_choptoI</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoI</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoI</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>&nbsp;
<BR>The target type may also be any of the other integer data types. A few examples
should suffice:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#chop">VF_choptoSI</a></TD><TD>neglect the fractional part and store as <B>short int / SmallInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoLI</a></TD><TD>round up and store as <B>long int / LongInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoQI</a></TD><TD>round downwards and store as quadruple integer, <B>quad / QuadInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#round">VF_roundtoU</a></TD><TD>round and store as <B>unsigned / UInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoUS</a></TD><TD>round up and store as <B>unsigned short / USmall</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VD_choptoUL</a></TD><TD>neglect the fractional part and store as <B>unsigned long / ULong</B></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6_2"></a>
<H2>4.6.2 Comparisons</H2>
Many numerical tasks rely on counting or selecting vector elements according to certain conditions which are formulated as comparisons. <BR>
Counting elements fulfilling a comparison condition is performed by the <a href="FUNCREF.HTM#cnt_">VF_cnt_...</a> series of functions.<BR>
Storing the result of the respective comparison for each element in a mask vector (which may subsequently used to mask out non-conforming vector elements in applications like time series analysis) is done by the <a href="FUNCREF.HTM#cmp_">VF_cmp_...</a> series.<BR>
As a third possibility, the indices of conforming elements can be stored in an index vector as is done by the <a href="FUNCREF.HTM#cmp_">VF_cmp_...ind</a> series.
<P>In all of these three series, every element of a vector can be compared either to 0, or to a constant C, or to the corresponding element of another vector.
<P>The condition to be tested is given by a postfix like "eq0", "ne0", "gtC", "leV". Testing if elements fall into a certain range is done by the functions with the postfixes "inclrange0C", "inclrangeCC", "exclrange0C" and "exclrangeCC".
<P>Additionally for the <a href="FUNCREF.HTM#cmp_">VF_cmp_...</a>  and <a href="FUNCREF.HTM#cmp_">VF_cmp_...ind</a> series, the <i>signum</i> function can be performed with the three possible answers +1 for &quot;greater than&quot;, 0 for &quot;equal to&quot; or -1 for &quot;less than&quot;. For input vectors of the unsigned integer data types, the output vectors are of the corresponding signed integer types.
<P>Here are some examples for these possibilites:
<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD><u>Counting functions</u>:</TD><TD>&nbsp;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cnt_">VF_cnt_eq0</a></TD><TD>count the number of elements equal to 0 (accepting -0 as valid)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cnt_">VD_cnt_gtC</a></TD><TD>count the number of elements greater than a constant <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cnt_">VE_cnt_leV</a></TD><TD>count the number of elements less than or equal to the corresponding elements of another vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cnt_">VLI_cnt_inclrange0C</a></TD><TD>count the number of elements xi falling into the range 0&nbsp;&lt;=&nbsp;xi&nbsp;&lt;=&nbsp;C or, if C is negative, 0&nbsp;&gt;=&nbsp;xi&nbsp;&gt;=&nbsp;C</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><u>Functions filling an output vector with 0 and 1 or +1 / 0 / -1</u>:</TD><TD>&nbsp;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp0">VF_cmp0</a></TD><TD>signum function: compare to 0: yi = +1, if xi &gt; 0; yi = 0, if xi = 0; yi = -1, if xi &lt; 0.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmpC">VU_cmpC</a></TD><TD>compare to a constant <I>C</I>: yi = +1, if xi &gt; C; yi = 0, if xi = C; yi = -1, if xi &lt; C.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmpV">VE_cmpV</a></TD><TD>compare corresponding vector elements:  zi = +1, if xi &gt; yi; zi = 0, if xi = yi; zi = -1, if xi &lt; yi</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp_">VUL_cmp_eq0</a></TD><TD>check if equal to 0: yi = 1, if xi = 0; otherwise yi = 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VQI_cmp_gtC</a></TD><TD>check if greater than a constant: : yi = 1, if xi &gt; C; otherwise yi = C <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_leV</a></TD><TD>check if less than or equal to corresponding vector element:  zi = 1, if xi &lt;= yi; otherwise zi = 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VSI_cmp_exclrangeCC</a></TD><TD>check if falling into a range specified by two constants CLo and CHi:  yi = 1, if  CLo &lt; xi &lt; CHi; otherwise yi = 0</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><u>Functions determining the indices of elements fulfilling a condition</u>:</TD><TD>&nbsp;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp_">VF_cmp_neCind</a></TD><TD>store indices of elements not equal to a constant <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VD_cmp_lt0ind</a></TD><TD>store indices of elements less than 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VE_cmp_geVind</a></TD><TD>store indices of elements greater than or equal to corresponding vector elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_exclrange0Cind</a></TD>
<TD>store indices of elements 0 &lt; xi &lt; C&nbsp;&nbsp;(C positive)<BR>or&nbsp;&nbsp;0 &gt; xi &gt; C&nbsp;&nbsp;(C negative)</TD></TR>
</TABLE>&nbsp;

<BR>If you want to know only if one or more given values can be found at all in a table (but do not need the exact number of occurrences), use one of the following functions:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#iselementC">VF_iselementC</a></TD>
<TD>returns TRUE, if <I>C</I> is an element of a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#iselementV">VF_iselementV</a></TD>
<TD>checks for each element of a vector if it is contained in a table</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_3"></a>
<H2>4.6.3 Direct Bit-Manipulation</H2>
For the integer data types, a number of bit-wise operations is available, which can be used, e.g., for fast multiplication and divisions by integer powers of 2.&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#shl">VI_shl</a></TD><TD>shift the bits to the left</TD></TR>
<TR><TD><a href="FUNCREF.HTM#shr">VI_shr</a></TD><TD>shift the bits to the right</TD></TR>
<TR><TD><a href="FUNCREF.HTM#or">VI_or</a></TD><TD>apply a bit mask in an OR operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xor">VI_xor</a></TD><TD>apply a bit mask in an XOR operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#not">VI_not</a></TD><TD>invert all bits</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>

<P><a name="chap4_6_4"></a>
<H2>4.6.4 Basic Arithmetics, Accumulations</H2>
As before, only the <I>VF_</I> function is explicitly named, but the <I>VD_</I> and <I>VE_</I> functions exist as well; if it makes sense, the same is true for the complex and for the integer-type versions:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#neg">VF_neg</a></TD><TD>Y<SUB>i</SUB> = - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#abs">VF_abs</a></TD><TD>Y<SUB>i</SUB> = | X<SUB>i</SUB> |</TD></TR>
<TR><TD><a href="FUNCREF.HTM#conj">VCF_conj</a></TD><TD>Y<SUB>i</SUB>.Re = X<SUB>i</SUB>.Re; Y<SUB>i</SUB>.Im = -(X<SUB>i</SUB>.Re)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#inv">VF_inv</a></TD><TD>Y<SUB>i</SUB> = 1.0 / X<SUB>i</SUB></TD></TR>
</TABLE>&nbsp;

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD VALIGN=TOP><TABLE BORDER WIDTH="97%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#equC">VF_equC</a></TD><TD>X<SUB>i</SUB> = C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#addC">VF_addC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> + C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subC">VF_subC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> - C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subrC">VF_subrC</a></TD><TD>Y<SUB>i</SUB> = C - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulC">VF_mulC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> * C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divC">VF_divC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> / C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrC">VF_divrC</a></TD><TD>Y<SUB>i</SUB> = C / X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#modC">VF_modC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> mod C</TD></TR>
</TABLE>
</TD>
<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#equV">VF_equV</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#addV">VF_addV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> + Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#subV">VF_subV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> - Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#subrV">VF_subrV</a></TD><TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulV">VF_mulV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> * Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divV">VF_divV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> / Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrV">VF_divrV</a></TD><TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> / X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#modV">VF_modV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> mod Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#add2V">VF_add2V</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> + Y1<SUB>i</SUB> + Y2<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sub2V">VF_sub2V</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> - Y1<SUB>i</SUB> - Y2<SUB>i</SUB></TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>&nbsp;
<BR>Besides these basic operations, several frequently-used combinations of addition and division have been included, not to forget the Pythagoras formula:&nbsp;
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR>
<TD WIDTH="50%">
<TABLE BORDER WIDTH="97%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#hypC">VF_hypC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#redC">VF_redC</a></TD><TD>Y<SUB>i</SUB> = (X<SUB>i</SUB> * C) / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#visC">VF_visC</a></TD><TD>Y<SUB>i</SUB> = (X<SUB>i</SUB> - C) / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#hypotC">VF_hypotC</a></TD><TD>Y<SUB>i</SUB> = sqrt( X<SUB>i</SUB>&sup2; + C&sup2; )</TD></TR>
</TABLE>
</TD>

<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#hypV">VF_hypV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#redV">VF_redV</a></TD><TD>Z<SUB>i</SUB> = (X<SUB>i</SUB> * Y<SUB>i</SUB>) / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#visV">VF_visV</a></TD><TD>Z<SUB>i</SUB> = (X<SUB>i</SUB> - Y<SUB>i</SUB>) / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#hypotV">VF_hypotV</a></TD><TD>Z<SUB>i</SUB> = sqrt( X<SUB>i</SUB>&sup2; + Y<SUB>i</SUB>&sup2;)</TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>
<P>All functions in the right column of the above two sections also exist in an expanded form (with the prefix <I>VFx_...</I>) in which the function is not evaluated for X<SUB>i</SUB> itself, but for the expression 
<BR>(a * X<SUB>i</SUB> + b), e.g.&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#addV">VFx_addV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B> + Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrV">VFx_divrV</a></TD>
<TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> / <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B></TD></TR>
</TABLE>
&nbsp;
<BR>The simple algebraic functions exist also in yet another special form, with the result being scaled by some arbitrary factor. This scaled form gets the prefix <I>VFs_</I>:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#addV">VFs_addV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subV">VFs_subV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> - Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulV">VFs_mulV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> * Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divV">VFs_divV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> / Y<SUB>i</SUB>)</TD></TR>
</TABLE>&nbsp;

<BR>Other simple operations include:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#maxC">VF_maxC</a></TD><TD>set Y<SUB>i</SUB> equal to X<SUB>i</SUB> or C, whichever is greater</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minC">VF_minC</a></TD><TD>choose the smaller of X<SUB>i</SUB> and C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#maxV">VF_maxV</a></TD><TD>set Z<SUB>i</SUB> equal to X<SUB>i</SUB> or Y<SUB>i</SUB>, whichever is greater</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minV">VF_minV</a></TD><TD>set Z<SUB>i</SUB> equal to X<SUB>i</SUB> or Y<SUB>i</SUB>, whichever is smaller</TD></TR>
<TR><TD><a href="FUNCREF.HTM#limit">VF_limit</a></TD><TD>limit the range of values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#flush0">VF_flush0</a></TD><TD>set all values to zero which are below a preset threshold</TD></TR>
<TR><TD><a href="FUNCREF.HTM#flushInv">VF_flushInv</a></TD><TD>set all values to zero which are below a preset threshold and take the inverse of all other values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#intfrac">VF_intfrac</a></TD><TD>split into integer and fractional parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mantexp">VF_mantexp</a></TD><TD>split into mantissa and exponent</TD></TR>
</TABLE>&nbsp;
<BR>While, in general, all <I>OptiVec</I> functions are for input and output vectors of the same type, the arithmetic functions exist also for mixed-type operations between the floating-point and the integer types. The result is always stored in the floating-point type. Examples are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#addVI">VF_addVI</a></TD><TD><B>fVector</B> Z = <B>fVector</B> X + <b>iVector</b> Y</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#mulVI">VD_mulVUL</a></TD><TD><B>dVector</B> Z = <B>dVector</B> X * <b>ulVector</b> Y</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#divrVI">VE_divrVBI</a></TD><TD><B>eVector</B> Z = <B>biVector</B> Y / <b>eVector</b> X</TD></TR></TABLE>
<P>Similarly, there exists a family of functions for the accumulation of data in either the same type or in higher-precision data types. Some examples are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#accV">VF_accV</a></TD><TD><B>fVector</B> Y += <B>fVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VD_accVF</a></TD><TD><B>dVector</B> Y += <B>fVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VF_accVI</a></TD><TD><B>fVector</B> Y += <B>iVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VQI_accVLI</a></TD><TD><B>qiVector</B> Y += <B>liVector</B> X</TD></TR>
</TABLE>&nbsp;
<BR>Additionally, within the floating-point data-types, you can accumulate two vectors at once:
&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#acc2V">VF_acc2V</a></TD><TD><B>fVector</B> Y += <B>fVector</B> X1 + <B>fVector</B> X2</TD></TR>
<TR><TD><a href="FUNCREF.HTM#acc2V">VD_acc2VF</a></TD><TD><B>dVector</B> Y += <B>fVector</B> X1 + <B>fVector</B> X2</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_5"></a>
<H2>4.6.5 Geometrical Vector Arithmetics</H2>
In its geometrical interpretation, a vector is a pointer, with its elements representing the coordinates of a point in <I>n</I>-dimensional space. There are a few functions for geometrical vector arithmetics, namely&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#scalprod">VF_scalprod</a></TD>
<TD>scalar product of two vectors</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xprod">VF_xprod</a></TD>
<TD>cross-product (or vector product) of two vectors</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Euclid">VF_Euclid</a></TD>
<TD>Euclidean norm</TD></TR>
</TABLE>

<P>If, on the other hand, two real input vectors X and Y, or one complex input vector XY, define the coordinates of several points in a planar coordinate system, there is a function to rotate these coordinates:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#rotateCoordinates">VF_rotateCoordinates</a></TD>
<TD>counter-clockwise rotation of the input coordinates specified by the vectors X and Y; the result is returned in the vectors Xrot and Yrot.</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#rotateCoordinates">VCF_rotateCoordinates</a></TD>
<TD>counter-clockwise rotation of the input coordinates specified by the cartesian complex vector XY; the result is returned in the vector XYrot.</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_6"></a>
<H2>4.6.6 Powers</H2>
The following functions raise arbitrary numbers to specified powers. While the "normal versions" perform full error handling, the extra-fast "unprotected versions" can be employed in situations where you are absolutely sure that all input elements yield valid results. Due to the much more efficient vectorization permitted by the absence of error checks, the unprotected functions are up to 1.8 times as fast as the normal, protected versions. (This is true from the Pentium CPU on; on older computers, almost nothing is gained.) Be, however, aware of the price you have to pay for this increase in speed: in case of an overflow error, the program will crash without any warning.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%">normal version</TD><TD WIDTH="27%">unprotected version</TD><TD>operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#square">VF_square</a></TD><TD><a href="FUNCREF.HTM#square">VFu_square</a></TD><TD>square</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cubic">VF_cubic</a></TD><TD><a href="FUNCREF.HTM#cubic">VFu_cubic</a></TD><TD>cubic</TD></TR>
<TR><TD><a href="FUNCREF.HTM#quartic">VF_quartic</a></TD><TD><a href="FUNCREF.HTM#quartic">VFu_quartic</a></TD><TD>quartic (fourth power)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow">VF_ipow</a></TD><TD><a href="FUNCREF.HTM#ipow">VFu_ipow</a></TD><TD>arbitrary integer powers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#pow">VF_pow</a></TD><TD>n.a.</TD><TD>fractional powers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#powexp">VF_powexp</a></TD><TD>n.a.</TD><TD>fractional powers, multiplied by exponential function: x<sup>r</sup>exp(x)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#poly">VF_poly</a></TD><TD><a href="FUNCREF.HTM#poly">VFu_poly</a></TD><TD>polynomial</TD></TR>
</TABLE>&nbsp;

<BR>The following group of functions is used to raise specified numbers to arbitrary powers:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#pow10">VF_pow10</a></TD>
<TD>fractional powers of 10</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow10">VF_ipow10</a></TD>
<TD>integer powers of 10 (stored as floating-point numbers)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#pow2">VF_pow2</a></TD>
<TD>fractional powers of 2</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow2">VF_ipow2</a></TD>
<TD>integer powers of 2 (stored as floating-point numbers)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp">VF_exp</a></TD>
<TD>exponential function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp10">VF_exp10</a></TD>
<TD>exponential function to the basis 10 (identical to <a href="FUNCREF.HTM#pow10">VF_pow10</a>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp2">VF_exp2</a></TD>
<TD>exponential function to the basis 2 (identical to <a href="FUNCREF.HTM#pow2">VF_pow2</a>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expArbBase">VF_expArbBase</a></TD>
<TD>exponential function of an arbitrary base</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sqrt">VF_sqrt</a></TD>
<TD>square-root (which corresponds to a power of 0.5)</TD></TR>
</TABLE>&nbsp;

<BR>All of these functions exist also in the expanded "<I>VFx_</I>" form, like
<BR><I><a href="FUNCREF.HTM#square">VFx_square</a></I>: Y<SUB>i</SUB> = <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B>&sup2;&nbsp;<BR>
The expanded form of the unprotected functions has the prefix <I>VFux_</I>.

<P>The complex-number equivalents are available as well, both for cartesian and polar coordinates. Additionally, two special cases are covered:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#powReExpo">VCF_powReExpo</a></TD>
<TD>real, fractional powers of complex numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp">VCF_exptoP</a></TD>
<TD>takes a cartesian input vector, returning its exponential function in polar coordinates.</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_7"></a>
<H2>4.6.7 Exponentials and Hyperbolic Functions</H2>
A variety of functions are derived from the exponential function <I><a href="FUNCREF.HTM#exp">VF_exp</a></I> (which
itself has already been mentioned in the last section).<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#exp">VF_exp</a></TD>
<TD>exponential function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expc">VF_expc</a></TD>
<TD>complementary exponential function Y<SUB>i</SUB> = 1 - exp[X<SUB>i</SUB>]</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expmx2">VF_expmx2</a></TD>
<TD>exponential function of the negative square of the argument,<BR>
Y<SUB>i</SUB> = exp( -X<SUB>i</SUB>&sup2; ). This is a bell-shaped function.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Gauss">VF_Gauss</a></TD>
<TD>Gaussian distribution function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#erf">VF_erf</a></TD>
<TD>Error function (Integral over the Gaussian distribution)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#erfc">VF_erfc</a></TD>
<TD>complementary error function, 1 - erf( X<SUB>i</SUB> )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#powexp">VF_powexp</a></TD><TD>fractional powers, multiplied by exponential function, X<SUB>i</SUB><sup>r</sup>exp(X<SUB>i</SUB>)</TD></TR>
</TABLE>
&nbsp;
<BR>The vectorized hyperbolic functions are available as:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinh">VF_sinh</a></TD>
<TD>hyperbolic sine</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosh">VF_cosh</a></TD>
<TD>hyperbolic cosine</TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanh">VF_tanh</a></TD>
<TD>hyperbolic tangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#coth">VF_coth</a></TD>
<TD>hyperbolic cotangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sech">VF_sech</a></TD>
<TD>hyperbolic secant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosech">VF_cosech</a></TD>
<TD>hyperbolic cosecant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sech2">VF_sech2</a></TD>
<TD>square of the hyperbolic secant</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_8"></a>
<H2>4.6.8 Logarithms</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#log10">VF_log10</a></TD>
<TD>decadic logarithm (to the basis 10)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#log">VF_log</a></TD>
<TD>natural logarithm (to the basis e)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ln">VF_ln</a></TD>
<TD>synonym for <a href="FUNCREF.HTM#log">VF_log</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#log2">VF_log2</a></TD>
<TD>binary logarithm (to the basis 2)</TD></TR>
</TABLE>&nbsp;
<BR>Again, the cartesian-complex equivalents exist as well. The polar-complex versions, however, are special in that their output is always in cartesian coordinates:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#log10">VPF_log10toC</a></TD>
<TD>decadic logarithm (to the basis 10)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#log">VPF_logtoC</a></TD>
<TD>natural logarithm (to the basis e)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ln">VPF_lntoC</a></TD>
<TD>synonym for <a href="FUNCREF.HTM#log">VPF_logtoC</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#log2">VPF_log2toC</a></TD>
<TD>binary logarithm (to the basis 2)</TD></TR>
</TABLE>

<BR>As a special form of the decadic logarithm, the Optical Density is made available by a family of functions of which some examples are contained in the following table:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VF_OD</a></TD><TD>OD = log10( X0/X ) for <B>fVector</B> as input and as output</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ODwDark">VF_ODwDark</a></TD><TD>OD = log10( (X0-X0Dark) / (X-XDark) ) for <B>fVector</B> as input and as output</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VUS_ODtoF</a></TD><TD>OD, calculated in <B>float</B> precision for <B>usVector</B> input</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VUL_ODtoD</a></TD><TD>OD, calculated in <B>double</B> precision for <B>ulVector</B> input</TD></TR>
<TR><TD><a href="FUNCREF.HTM#OD">VQI_ODtoEwDark</a></TD><TD>OD with dark-current correction, calculated in <B>extended</B> precision for <B>qiVector</B> input</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_9"></a>
<H2>4.6.9 Trigonometric Functions</H2>
Some of the basic trigonometric functions are available in two variants. The first variant follows the usual rules of error handling for math functions, whereas the second is for situations where you know beforehand that all input arguments will be in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>. If you choose to employ these extra-fast reduced-range functions, you really have to be absolutely sure about your input vectors, as these functions will crash without warning in the case of any input number outside the range specified above. The reduced-range functions are available only for the sine and cosine, as all other trigonometric functions need error checking and handling anyway, even in this range.<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin">VF_sin</a></TD><TD>sine</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin">VFr_sin</a></TD><TD>extra-fast &quot;reduced-range&quot; sine function for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD>
</TR><TR><TD><a href="FUNCREF.HTM#cos">VF_cos</a></TD><TD>cosine</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cos">VFr_cos</a></TD><TD>cosine for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincos">VF_sincos</a></TD><TD>sine and cosine at once</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sincos">VFr_sincos</a></TD><TD>sine and cosine for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tan">VF_tan</a></TD><TD>tangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cot">VF_cot</a></TD><TD>cotangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sec">VF_sec</a></TD><TD>secant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosec">VF_cosec</a></TD><TD>cosecant</TD></TR>
</TABLE>
&nbsp;
<BR>The following functions yield the squares of the trigonometric functions in a more efficient way than by first calculating the basic functions and squaring afterwards:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin2">VF_sin2</a></TD><TD>sine&sup2;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin2">VFr_sin2</a></TD><TD>sine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cos2">VF_cos2</a></TD><TD>cosine&sup2;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cos2">VFr_cos2</a></TD><TD>cosine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincos2">VF_sincos2</a></TD><TD>sine&sup2; and cosine&sup2; at once</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sincos2">VFr_sincos2</a></TD><TD>sine&sup2; and cosine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tan2">VF_tan2</a></TD><TD>tangent&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cot2">VF_cot2</a></TD><TD>cotangent&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sec2">VF_sec2</a></TD><TD>secant&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosec2">VF_cosec2</a></TD><TD>cosecant&sup2;</TD></TR>
</TABLE>&nbsp;

<BR>A very efficient way to calculate the trigonometric functions for arguments representable as rational multiples of <FONT FACE="Symbol">p</FONT> (PI) is supplied by the trigonometric functions with the suffix &quot;rpi&quot; (meaning &quot;rational multiple of <FONT FACE="Symbol">p</FONT>&quot;). Here, r = p / q, where q is constant and p is given by the input vector elements:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinrpi">VF_sinrpi</a></TD><TD>sine of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosrpi">VF_cosrpi</a></TD><TD>cosine of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincosrpi">VF_sincosrpi</a></TD><TD>sine and cosine of p/q * <FONT FACE="Symbol">p</FONT> at once</TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanrpi">VF_tanrpi</a></TD><TD>tangent of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cotrpi">VF_cotrpi</a></TD><TD>cotangent of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#secrpi">VF_secrpi</a></TD><TD>secant of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosecrpi">VF_cosecrpi</a></TD><TD>cosecant of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
</TABLE>&nbsp;

<BR>Even more efficient versions use tables to obtain frequently-used values; these versions are denoted by the suffixes &quot;rpi2&quot; (multiples of <FONT FACE="Symbol">p</FONT> divided by an integer power of 2) and &quot;rpi3&quot; (multiples of <FONT FACE="Symbol">p</FONT> over an integer multiple of 3). Examples are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinrpi">VF_sinrpi2</a></TD>
<TD>sine of p / 2<SUP>n</SUP> * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanrpi">VF_tanrpi3</a></TD>
<TD>tangent of p / (3*n) * <FONT FACE="Symbol">p</FONT></TD></TR>
</TABLE>
&nbsp;
<BR>Two more special trigonometric functions are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinc">VF_sinc</a></TD>
<TD>sinc function, Y<SUB>i</SUB> = sin( X<SUB>i</SUB> ) / X<SUB>i</SUB></TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#Kepler">VF_Kepler</a></TD>
<TD>Kepler function, calculating the time-dependent angular position of a planet or comet</TD></TR>
</TABLE>&nbsp;

<BR>Vectorized inverse trigonometric functions are available as&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#asin">VF_asin</a></TD><TD>arc sin</TD></TR>
<TR><TD><a href="FUNCREF.HTM#acos">VF_acos</a></TD><TD>arc cos</TD></TR>
<TR><TD><a href="FUNCREF.HTM#atan">VF_atan</a></TD><TD>arc tan</TD></TR>
<TR><TD><a href="FUNCREF.HTM#atan2">VF_atan2</a></TD>
<TD>arc tan of ratios, Z<SUB>i</SUB> = atan( Y<SUB>i</SUB> / X<SUB>i</SUB> )</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_7"></a>
<H2>4.7 Analysis</H2>
There is a number of functions probing the analytical properties of data arrays:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#derivV">VF_derivV</a></TD>
<TD>derivative of a Y-array with respect to an X-array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#derivC">VF_derivC</a></TD>
<TD>the same for constant intervals between the X-values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#integralV">VF_integralV</a></TD>
<TD>value of the integral of a Y-array over an X-array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runintegralV">VF_runintegralV</a></TD>
<TD>point-by-point ("running") integral</TD></TR>
<TR><TD><a href="FUNCREF.HTM#integralC">VF_integralC</a></TD>
<TD>integral over an equally spaced X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runintegralC">VF_runintegralC</a></TD>
<TD>point-by-point integral over an equally spaced X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ismonoton">VF_ismonoton</a></TD>
<TD>test if an array is monotonously rising or falling</TD></TR>
<TR><TD><a href="FUNCREF.HTM#iselementC">VF_iselementC</a></TD>
<TD>test, if a given value occurs within a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#searchC">VF_searchC</a></TD>
<TD>search an ordered table for the entry whose value comes closest to a preset value <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#localmaxima">VF_localmaxima</a></TD>
<TD>detect local maxima (points whose right and left neighbours are smaller)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#localminima">VF_localminima</a></TD>
<TD>detect local minima (points whose right and left neighbours are larger)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#max">VF_max</a></TD>
<TD>detect global maximum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#min">VF_min</a></TD>
<TD>detect global minimum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minmax">VF_minmax</a></TD>
<TD>detect global minimum and maximum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#maxind">VF_maxind</a></TD>
<TD>global maximum and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minind">VF_minind</a></TD>
<TD>global minimum and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmax">VF_absmax</a></TD>
<TD>global maximum absolute value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmin">VF_absmin</a></TD>
<TD>global minimum absolute value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminmax">VF_absminmax</a></TD>
<TD>detect global minimum and maximum absolute values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxind">VF_absmaxind</a></TD>
<TD>global maximum absolute value and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminind">VF_absminind</a></TD>
<TD>global minimum absolute value and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#maxexp">VF_maxexp</a></TD>
<TD>global maximum exponent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minexp">VF_minexp</a></TD>
<TD>global minimum exponent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runmax">VF_runmax</a></TD>
<TD>&quot;running&quot; maximum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runmin">VF_runmin</a></TD>
<TD>&quot;running&quot; minimum</TD></TR>
</TABLE>
<P>The complex equivalents of the last group of functions are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#maxReIm">VCF_maxReIm</a></TD>
<TD>maximum real and imaginary parts separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minReIm">VCF_minReIm</a></TD>
<TD>minimum real and imaginary parts separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxReIm">VCF_absmaxReIm</a></TD>
<TD>maximum absolute real and imaginary values separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminReIm">VCF_absminReIm</a></TD>
<TD>minimum absolute real and imaginary values separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmax">VCF_absmax</a></TD>
<TD>largest magnitude (absolute value; this is a real number)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmin">VCF_absmin</a></TD>
<TD>smallest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cabsmax">VCF_cabsmax</a></TD>
<TD>complex number of largest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cabsmin">VCF_cabsmin</a></TD>
<TD>complex number of smallest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sabsmax">VCF_sabsmax</a></TD>
<TD>complex number for which the sum |Re| + |Im| is largest</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sabsmin">VCF_sabsmin</a></TD>
<TD>smallest complex number in terms of the sum |Re| + |Im|</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxind">VCF_absmaxind</a></TD>
<TD>largest magnitude (absolute value) and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminind">VCF_absminind</a></TD>
<TD>smallest magnitude and its index</TD></TR>
</TABLE>&nbsp;

<BR>Sums, products, etc. are available by functions grouped as statistical building blocks and summarized in <a href="#chap4_9">chapter 4.9</A>.&nbsp;

<P>To determine the center of gravity of a vector, you have the choice between the following two functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR VALIGN="TOP"><TD><a href="FUNCREF.HTM#COGI">VF_centerOfGravityInd</a></TD><TD>center of gravity, returned as an interpolated element index</TD></TR>
<TR VALIGN="TOP"><TD><a href="FUNCREF.HTM#COGV">VF_centerOfGravityV</a></TD><TD>center of gravity of a Y vector with explicitly given X axis</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<A NAME="chap4_8"></A>
<h2>4.8 Signal Processing:
<BR>Fourier Transforms and Related Topics</h2>
The following list of functions is available for signal processing applications:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#FFT">VF_FFTtoC</a></TD>
<TD>forward Fast Fourier Transform (FFT) of a real vector; the result is a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FFT">VF_FFT</a></TD>
<TD>forward and backward FFT of a real vector; the result of the forward FFT is packed into a real vector of the same size as the input vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FFT">VCF_FFT</a></TD>
<TD>forward and backward FFT of a complex vector</TD></TR>
<TR><TD><a href="MATRIX.HTM#Rows_FFT">MF_Rows_FFT</a></TD><TD>FFT along the rows of a matrix; this function may be used for batch-processing of several vectors of identical size, stored as the rows of a matrix</TD></TR>
<TR><TD><a href="MATRIX.HTM#Cols_FFT">MF_Cols_FFT</a></TD><TD>FFT along the columns of a matrix; this function may be used for batch-processing of several vectors of identical size, stored as the columns of a matrix</TD></TR>
<TR><TD><a href="FUNCREF.HTM#convolve">VF_convolve</a></TD>
<TD>convolution with a given response function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#deconvolve">VF_deconvolve</a></TD>
<TD>deconvolution, assuming a given response function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#filter">VF_filter</a></TD>
<TD>spectral filtering</TD></TR>
<TR><TD><a href="FUNCREF.HTM#spectrum">VF_spectrum</a></TD>
<TD>spectral analysis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#autocorr">VF_autocorr</a></TD>
<TD>autocorrelation function of a data array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xcorr">VF_xcorr</a></TD>
<TD>cross-correlation function of two arrays</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></TD>
<TD>set editing threshold for the filter in convolutions and deconvolutions
(decides over the treatment of "lost" frequencies)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#getRspEdit">VF_getRspEdit</a></TD>
<TD>retrieve the current editing threshold</TD></TR>
</TABLE>

<P>The FFT algorithm chosen for this PC implementation is a radix-2 Cooley-Tukey routine.
<BR>For historical reasons, there are three different versions of all FFT-based functions, with the prefixes <i>VFp_, VFs_</i>, and <i>VFl_</i>. The "normal" version, <i>VF_</i>, is identical to the <i>VFp_</i> function. The "p" stands for "parallelized", as this variant is designed to make optimal use of the XMM / YMM registers and corresponding SIMD commands of modern processors. The <i>VFs_</i> and <i>VFl_</i> versions use the FPU. They are very slightly more accurate, but much slower. The <i>VFs_</i> and <i>VFl_</i> versions have been deprecated and will likely be removed from future releases. 
<P>Although they do not use Fourier transform methods, the functions <I><a href="FUNCREF.HTM#biquad">VF_biquad</a></I> (bi-quadratic audio filtering) and <I><a href="FUNCREF.HTM#smooth">VF_smooth</a></I> (crude form of frequency filtering which removes high-frequency noise) should be mentioned here.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_9"></a>
<H2>4.9 Statistical Functions and Building Blocks</H2>
The following collection of statistical functions is offered by <I>OptiVec</I>:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sum">VF_sum</a></TD>
<TD>sum of all elements</TD></TR>
<TR valign="top"><TD><a href="FUNCREF.HTM#fsum">VI_fsum</a></TD>
<TD>sum of all elements of an integer vector, accumulated as a floating point number in double or extended precision</TD></TR>
<TR><TD><a href="FUNCREF.HTM#prod">VF_prod</a></TD>
<TD>product of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssq">VF_ssq</a></TD>
<TD>sum-of-squares of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumabs">VF_sumabs</a></TD>
<TD>sum of absolute values of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#rms">VF_rms</a></TD>
<TD>root-of-the-mean-square of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runsum">VF_runsum</a></TD>
<TD>running sum, also called "cumulative sum" or "inclusive sum-scan"</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runprod">VF_runprod</a></TD>
<TD>running product</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumdevC">VF_sumdevC</a></TD>
<TD>sum over the deviations from a preset constant, sum( |X<SUB>i</SUB>-C| )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumdevV">VF_sumdevV</a></TD>
<TD>sum over the deviations from another vector, sum( |X<SUB>i</SUB>-Y<SUB>i</SUB>|&nbsp;)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#avdevC">VF_avdevC</a></TD>
<TD>average deviation from a preset constant, 1/N * sum( |X<SUB>i</SUB>-C| )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#avdevV">VF_avdevV</a></TD>
<TD>average deviation from another vector, 1 / N * sum( |X<SUB>i</SUB>-Y<SUB>i</SUB>|&nbsp;)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssqdevC">VF_ssqdevC</a></TD>
<TD>sum-of-squares of the deviations from a preset constant,<BR>
sum( (X<SUB>i</SUB> - C)&sup2; )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssqdevV">VF_ssqdevV</a></TD>
<TD>sum-of-squares of the deviations from another vector,<BR>
sum( (X<SUB>i</SUB> - Y<SUB>i</SUB>)&sup2; )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chi2">VF_chi2</a></TD>
<TD>chi-square merit function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chiabs">VF_chiabs</a></TD>
<TD>&quot;robust&quot; merit function, similar to <a href="FUNCREF.HTM#chi2">VF_chi2</a>, but based on absolute instead of squared deviations</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mean">VF_mean</a></TD>
<TD>equally-weighted mean (or average) of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanwW">VF_meanwW</a></TD>
<TD>&quot;mean with weights&quot; of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanabs">VF_meanabs</a></TD>
<TD>equally-weighted mean (or average) of the absolute values of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#selected_mean">VF_selected_mean</a></TD>
<TD>averages only those vector elements which fall into a specified range, thus allowing to exclude outlier points from the calculation of the mean</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceC">VF_varianceC</a></TD>
<TD>variance of a distribution with respect to a preset constant value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceCwW">VF_varianceCwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceV">VF_varianceV</a></TD>
<TD>variance of one distribution with respect to another</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceVwW">VF_varianceVwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanvar">VF_meanvar</a></TD>
<TD>mean and variance of a distribution simultaneously</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanvarwW">VF_meanvarwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#median">VF_median</a></TD>
<TD>median of a distribution</TD></TR>
<TR><TD><a href="FUNCREF.HTM#corrcoeff">VF_corrcoeff</a></TD>
<TD>linear correlation coefficient of two distributions</TD></TR>
<TR><TD><a href="FUNCREF.HTM#distribution">VF_distribution</a></TD>
<TD>histogram calculation - bins data into a discrete one-dimensional distribution function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#stats">VF_min_max_mean_stddev</a></TD>
<TD>simultaneous calculation of the minimum, maximum, mean, and standard deviation of a one-dimensional distribution</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_10"></a>
<H2>4.10 Data Fitting</H2>
Ranging from a simple linear regression to complex fitting problems involving multiple data sets and nonlinear functions with many adjustable parameters, <I>OptiVec</I> offers routines for virtually all practically occurring tasks of data fitting. As all of them, except for simple linear regression, rely on matrix methods, they actually form a part of <I>MatrixLib</I>. This means you have to <font face="courier new">#include &lt;MFstd.h&gt; (&lt;MDstd.h&gt;&lt; MEstd.h&gt;)</font> or the unit MFstd, (MDstd, MEstd).
<P>A detailed description of the various data-fitting concepts is given in <a href="MATRIX.HTM#chap13">chapter 13 of MATRIX.HTM</a>. Therefore, at this place, the available X-Y fitting functions are only summarized in the following table:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#linregress">VF_linregress</a></TD>
<TD>equally-weighted linear regression on X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#linregress">VF_linregresswW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#polyfit">VF_polyfit</a></TD>
<TD>fitting of one X-Y data set to a polynomial</TD></TR>
<TR><TD><a href="MATRIX.HTM#polyfit">VF_polyfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#linfit">VF_linfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary function linear in its parameters</TD></TR>
<TR><TD><a href="MATRIX.HTM#linfit">VF_linfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#setLinfitNeglect">VF_setLinfitNeglect</a></TD>
<TD>set threshold to neglect (i.e. set equal to zero) a fitting parameter A[i], if its significance is smaller than the threshold</TD></TR>
<TR><TD><a href="MATRIX.HTM#getLinfitNeglect">VF_getLinfitNeglect</a></TD>
<TD>retrieve current significance threshold</TD></TR>
<TR><TD><a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#nonlinfit">VF_nonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiLinfit">VF_multiLinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common linear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiLinfit">VF_multiLinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiNonlinfit">VF_multiNonlinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiNonlinfit">VF_multiNonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_11"></a>
<H2>4.11 Input and Output</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cprint">VF_cprint</a></TD>
<TD>print the elements of a vector to the screen (or "console" &#x2013; hence the "c" in the name) into the current text window. Borland/Embarcadero compilers: the height and width of the text window are automatically detected. Microsoft compilers: a default linewidth of 80 characters is assumed. After printing one page, the user is prompted to continue. (Only for console applications)</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#print">VF_print</a></TD>
<TD>is similar to <a href="FUNCREF.HTM#cprint">VF_cprint</a> in that the output is directed to the screen, but there is no automatic detection of the screen data; a default linewidth of 80 characters is assumed, and no division into pages is made. (Only for console applications)</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#fprint">VF_fprint</a></TD>
<TD>print a vector to a stream.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#write">VF_write</a></TD>
<TD>write data in ASCII format in a stream</TD></TR>
<TR><TD><a href="FUNCREF.HTM#read">VF_read</a></TD>
<TD>read a vector from an ASCII file</TD></TR>
<TR><TD><a href="FUNCREF.HTM#nwrite">VF_nwrite</a></TD>
<TD>write <I>n</I> vectors of the same data type as the columns of a table into a stream</TD></TR>
<TR><TD><a href="FUNCREF.HTM#nread">VF_nread</a></TD>
<TD>read the columns of a table into <I>n</I> vectors of the same type</TD></TR>
<TR><TD><a href="FUNCREF.HTM#store">VF_store</a></TD>
<TD>store data in binary format</TD></TR>
<TR><TD><a href="FUNCREF.HTM#recall">VF_recall</a></TD>
<TD>retrieve data in binary format</TD></TR>
</TABLE>

<P>The following functions allow to modify the standard settings of <I><a href="FUNCREF.HTM#write">VF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#nwrite">VF_nwrite</a></I> and <I><a href="FUNCREF.HTM#read">VI_read</a></I>:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#setWriteFormat">VF_setWriteFormat</a></TD>
<TD>define a certain number format</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setWriteSeparate">VF_setWriteSeparate</a></TD>
<TD>define a separation string between successive elements, written by <I><a href="FUNCREF.HTM#write">VF_write</a></I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#setNWriteSeparate">VF_setNWriteSeparate</a></TD>
<TD>define a separation string between the columns written by <I><a href="FUNCREF.HTM#nwrite">VF_nwrite</a></I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#setRadix">V_setRadix</a></TD>
<TD>define a radix different from the standard of 10 for the whole-number variants of the <I>V.._read</I> functions</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_12"></a>
<H2>4.12 Graphics</H2>
<I>VectorLib</I> includes a range of data-plotting routines. Before any of them may be used, <I>VectorLib</I> graphics has to be initialized:<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#initPlot">V_initPlot</a></TD>
<TD>initialize <I>VectorLib</I> graphics functions (both Windows and DOS). For Windows, no shut-down is needed at the end, since the Windows graphics functions always remain accessible. <I>V_initPlot</I> automatically reserves a part of the screen for plotting operations. This part comprises about 2/3 of the screen on the right side. Above, one line is left for a heading. Below, a few lines are left empty. To change this default plotting region, call <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPlot</I>.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#initGraph">V_initGraph</a></TD>
<TD>simultaneously initialize Borland's graphics interface and <I>VectorLib</I> plotting functions (DOS only). Do not call <I>initgraph</I> after <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>. If, on the other hand, you have already called <I>initgraph</I>, do <U>not</U> use <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>, but <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> instead. At the end of the graphics session, the BGI function
<I>closegraph</I> has to be used to leave the graphics mode and to release graphics buffer memory.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#initPrint">V_initPrint</a></TD>
<TD>initialize <I>VectorLib</I> graphics functions and direct them to a printer (Windows only). By default, one whole page is reserved for plotting. In order to change this, call <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPrint</I>.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></TD>
<TD>set a plotting region different from the default</TD></TR>
</TABLE>

<P><I>VectorLib</I> distinguishes between two sorts of plotting functions, <I>AutoPlot</I> and <I>DataPlot</I>. All <I>AutoPlot</I> functions (e.g., <I><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></I>) execute the following steps:
<OL><LI>define a viewport within the plotting region (which is either the default region or the one defined by calling <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I>)
<LI>clear the viewport
<LI>generate a Cartesian coordinate system with suitably scaled and labeled axes
<LI>plot the data according to the parameters passed to the function
</OL>
All <I>DataPlot</I> functions execute only the last step. They assume that a coordinate system already exists from a previous
call to any of the <I>AutoPlot</I> functions, to <I><a href="FUNCREF.HTM#findAxes">V_findAxes</a></I>, or to <I><a href="FUNCREF.HTM#drawAxes">V_drawAxes</a></I>. The new plot is added to the existing one. All settings of this coordinate system have to be valid. The viewport must still be the active one and the scaling of the axes has to fit also for
the new data plot.
<BR>To add text and lables, a new viewport must be defined. Use <I>SetViewportOrgEx</I> (32-bit Windows), <I>SetViewportOrg</I> (16-bit Windows), or <I>setviewport</I> (DOS).<BR>
<BR>If you wish to switch back into text mode in DOS, use <I>restorecrtmode</I>. After that, a new call to <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> (not <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>!) brings you back into graphics mode.

<BR>For all plotting functions, the different plot styles (symbols, lines, and colors), are specified as parameters, see <I><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></I>. Here is a list of the available <I>AutoPlot</I> and <I>DataPlot</I> routines:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></TD>
<TD>display an automatically-scaled plot of an X-Y vector pair</TD></TR>
<TR><TD><a href="FUNCREF.HTM#yAutoPlot">VF_yAutoPlot</a></TD>
<TD>plot a single Y-vector, using the index as X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xy2AutoPlot">VF_xy2AutoPlot</a></TD>
<TD>plot two X-Y pairs at once, scaling the axes in such a way that both
vectors fit into the same coordinate system</TD></TR>
<TR><TD><a href="FUNCREF.HTM#y2AutoPlot">VF_y2AutoPlot</a></TD>
<TD>the same for two Y-vectors, plotted against their indices</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xyDataPlot">VF_xyDataPlot</a></TD>
<TD>plot one additional set of X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#yDataPlot">VF_yDataPlot</a></TD>
<TD>plot one additional Y vector over its index</TD>
</TR>
</TABLE>
<P>Cartesian complex arrays are printed into the complex plane (the imaginary parts versus the real parts), using<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#autoPlot">VCF_autoPlot</a></TD>
<TD>plot one cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#c2AutoPlot">VCF_2AutoPlot</a></TD>
<TD>plot two cartesian complex vectors simultaneously</TD></TR>
<TR><TD><a href="FUNCREF.HTM#dataPlot">VCF_dataPlot</a></TD>
<TD>plot one additional cartesian complex vector</TD></TR>
</TABLE>
<P>At present, there are no plotting functions for polar complex vectors included.
<BR>It is possible to draw more than one coordinate systems into a given window on the screen. The position of each coordinate system must be specified by the above-mentioned function <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I>. &quot;Hopping&quot; between the different coordinate systems and adding new DataPlots after defining new viewports (e.g., for text output) is made possible by the following functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#continuePlot">V_continuePlot</a></TD>
<TD>go back to the viewport of the last plot and restore its scalings</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#getCoordSystem">V_getCoordSystem</a></TD>
<TD>get a copy of the scalings and position of the current coordinate system</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#setCoordSystem">V_setCoordSystem</a></TD>
<TD>restore the scalings and position of a coordinate system; these must have been stored previously, using <I><a href="FUNCREF.HTM#getCoordSystem">V_getCoordSystem</a></I></TD></TR>
</TABLE>
<P><U>DOS only:</U>
<BR>When using multiple coordinate systems on the same screen, the default font used for axis labeling might be too large, so that neighbouring labels overlap each other. In these cases, use the BGI function <I>settextstyle</I> to switch to another font before calling an <I>AutoPlot</I> function.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap5"></a>
<HR width="100%"><H1>5. Error Handling </H1>

<P><a name="chap5_1"></a>
<H2>5.1 General Remarks</H2>
There are two general types of error handling: by the hardware, or by the software. In order to prevent uncontrolled program crash, it is highly desirable that conditions, leading to hardware errors, be recognized before the errors actually occur. All high-level computer languages support this software error-handling to various degrees of perfection. Within the
tightly-defined functions and routines of this <I>OptiVec</I> package, often an even more efficient error handling by the program itself is possible than provided by the compilers for user-written code.
<BR>However, it should be noted that no absolute overflow protection is possible for the extended-precision versions. They do not have a &quot;safety margin&quot; left as in the single- and double-precision versions, where internally all calculations are performed in extended precision. Especially the <I>VEx_</I> and <I>VCEx_</I> versions may fail if constant parameters are very large, or if the X vector elements themselves are already near the overflow limit. To be on the safe side, constant parameters should not exceed about 1.E32 for float, 1.E150 for double, and 1.E2000 for extended parameters.
<P>In the &quot;expanded&quot; versions of all functions with extended accuracy (those with the prefixes <I>VEx_</I> and <I>VCEx_</I>; for example <I><a href="FUNCREF.HTM#exp">VEx_exp</a></I>), there is generally no overflow protection for the calculation of A*X<sub>i</sub>+B, but only for the core of the function itself and for the final multiplication by C.
<P>A series of identical errors occurring within one and the same <I>OptiVec</I> function leads to one error message only. Subsequent identical messages are suppressed.
<P>There is a fundamental difference between floating-point and integer numbers with respect to OVERFLOW and DOMAIN errors: for floating-point numbers, these are always serious errors, whereas for integer numbers, by virtue of the implicit modulo-2<sup>n</sup> arithmetics, this is not necessarily the case. In the following two paragraphs, details are given on the error handling of integer and floating-point numbers, respectively.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_2"></a>
<H2>5.2 Integer Errors</H2>
The only genuine integer errors are ZERODIVIDE errors (if a division by 0 is attempted). Other integer errors are neglected due to the implicit definition of integer operations as being performed modulo the respective power of 2 (see <a href="#chap4_4">chapter 4.4</a>). For those situations in which implicit modulo 2<sup>n</sup> arithmetics is not appropriate, <I>OptiVec</I> offers the possibility to trap these errors and print an error message and/or abort the program. 
<BR>All functions where INTEGER OVERFLOW (e.g., in <I><a href="FUNCREF.HTM#ramp">VI_ramp</a>,&nbsp; <a href="FUNCREF.HTM#mulV">VI_mulV</a></I>, etc.) or INTEGER DOMAIN errors (e.g., in <I><a href="FUNCREF.HTM#ItoBI">V_ItoU</a></I> for negative X-values) may occur, exist in two versions: the &quot;normal&quot; version employs modulo 2<sup>n</sup> arithmetics and interchanges signed and unsigned data types according to their bit pattern. For the 16-bit and 32-bit integer types (but not for 8-bit and 64-bit), there is a second version which also employs modulo 2<sup>n</sup> arithmetics, but detects the errors. This second variant is denoted by the letter &quot;o&quot; (for &quot;overflow detection&quot;) in the prefix:  <I>VIo_,&nbsp; VSIo_,&nbsp; VULo_</I>, etc. (for the data-type interconversion functions, the prefix <I>V_</I> is changed into <I>Vo_</I>).  Here, the action to be taken in the case of INTEGER OVERFLOW or INTEGER DOMAIN errors has to be defined by calling <I><a href="FUNCREF.HTM#setIntErrorHandling">V_setIntErrorHandling</a></I> somewhere before the call to the <I>VIo_</I> function. <I>V_setIntErrorHandling</I> takes an argument of the type V_ihand (defined in &lt;VecLib.h&gt; and the unit VecLib) with one of three possible values:<BR>&nbsp;
<table border width="100%"><tr><td>ierrNote</td><td>print an error message</td></tr>
<tr><td>ierrAbort</td><td>print an error message and exit the program</td></tr>
<tr valign="top"><td>ierrIgnore&nbsp;</td><td>ignore the problem. With this last option, the error handling can be switched off intermediately.</td></tr>
</table>
<P>Although you may use a call to<BR>
<font face="courier new">V_setIntErrorHandling( ierrIgnore );</font><BR>
to switch the error handling off, it is always better simply to use the &quot;normal&quot; <I>VI_</I> version rather than the <I>VIo_</I> version with the error-handling short-cut, as the normal version is always much faster.

<P><U>C/C++ only:</U><BR>
To choose the overflow-detecting version not only for single function calls, but everywhere, the easiest way is to define symbolic constant <I>V_trapIntError</I> in the program header before(!) &lt;VecLib.h&gt; is included:
<BR>Example:<font face="courier new">
<BR>#define V_trapIntError 1
<BR>#include &lt;VIstd.h&gt;
<BR>#include &lt;VImath.h&gt;
<BR>.....
<BR>main() /* or WinMain(), or OwlMain() */
<BR>{
<BR>&nbsp;&nbsp;iVector I1, I2;
<BR>&nbsp;&nbsp;I1 = <a href="FUNCREF.HTM#vector">VI_vector</a>( 1000 ); I2 = VI_vector( 1000 );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#setIntErrorHandling">V_setIntErrorHandling</a>( ierrNote );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#ramp">VI_ramp</a>( I1, 1000, 0, 50 ); /* an overflow will occur here! */
<BR>&nbsp;&nbsp;V_setIntErrorHandling( ierrIgnore );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#mulC">VI_mulC</a>( I2, I1, 1000, 5 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/* here, even a whole series of overflows will occur; they are all ignored. */
<BR>&nbsp;&nbsp;....
<BR>}</font>


<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3"></a>
<H2>5.3 Floating-Point Errors</H2>
<P><a name="chap5_3_1"></a>
<H2>5.3.1 C/C++ specific</H2>
In order to understand the details of the floating-point error handling outlined in the following sections, you may wish to refer to the description of the functions <I>_matherr</I> and <I>signal</I> in the documentation of your C++ compiler.
<BR>Keep in mind that <I>_matherr</I> and <I>_matherrl</I> are the user-definable focal points for the handling of all software-detected errors, whereas <I>signal</I> is used to install a handler for hardware-detected errors (which should better be avoided in the first place). Within the <I>OptiVec</I> functions, <I>_matherr</I> is used for the error handling in the <I>VF_,&nbsp; VCF_,&nbsp; VD_</I>, and <I>VCD_</I> versions. <I>_matherrl</I> is used in the <I>VE_</I> and <I>VCE_</I> versions (32-bit Embarcadero / Borland C++ only, as neither Visual C++ nor 64-bit RAD Studio support 80-bit real numbers).
<P>If the function in which an error occurs has one real-valued argument, only the parameter e-&gt;x is defined in calling <I>_matherr</I> and e-&gt;y is left undefined. Only if there are two arguments (like in <I><a href="FUNCREF.HTM#atan2">VF_atan2</a></I> or in <I><a href="FUNCREF.HTM#cotrpi">VF_cotrpi</a></I>),
both e-&gt;x and e-&gt;y are needed to hold these arguments. For complex arguments, the real part (or the Mag part for polar coordinates) is stored in e-&gt;x and the imaginary part (or the Arg part) in e-&gt;y.
<P>From <i>OptiVec</i> version 6.1 on, this error handling via <i>_matherr</i> is performed only in the Debug libraries (name ending in "D"). The general-purpose, multi-thread, and large-vector libraries employ a simplified procedure, whereby overflow, singularity, and loss-of-precision errors are treated "silently" by setting the result to the default value indicated for each function in <a href="FUNCREF.HTM#atan2">FUNCREF.HTM</a>. Here, <i>_matherr</i> is called only in the case of DOMAIN errors with the proposed result NAN  (not-a-number).
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3_2"></a>
<H2>5.3.2 Pascal/Delphi specific</H2>
The types of errors occurring in mathematical functions are described in detail <a href="#chap5_3_3">below</a>. How <I>OptiVec</I> handles each type of error is defined by a call to  <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>.  The possible options are set by the <I>fperrXXX</I> constants described with <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>. When calling <I>V_setFPErrorHandling</I>, combine these constants by the OR operator. Note that this influences only the way errors are handled within <I>OptiVec</I> functions. It does not affect the way how the standard Borland Pascal/Delphi functions handle errors.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3_3"></a>
<H2>5.3.3 Error Types (Both C/C++ and Pascal/Delphi)</H2>
For each <I>VectorLib</I> function, the types of errors that are detected and handled are described in the <a href="FUNCREF.HTM#chap8">Alphabetical Reference</a>. All functions derived from ANSI C or Pascal math functions (those whose declarations are to be found in &lt;V?math.h&gt; or the units V?math) contain a fully-fledged mathematical error handling. In addition to the error handling &quot;by element&quot;, their return value shows if all elements have been processed error-free (return value FALSE or 0) or if an error occurred and was handled (return value TRUE or different from 0).
<P>In the following description of all floating-point error types, we denote by &quot;HUGE_VAL&quot; the largest number possible in the respective data type. Similarly, &quot;TINY_VAL&quot; is the smallest denormal number representable in the
respective data type; this is not the same as &quot;MIN_VAL&quot;, which is the smallest full-accuracy number of the respective data type.
<UL>
<LI>DOMAIN errors most often lead to the result NAN (&quot;not-a-number&quot;). Even if nothing happens within the function itself that detects a DOMAIN error, an uncontrolled program crash may result if subsequent operations are performed on the vector element set to NAN. 
<BR><U>For C/C++</U>, we therefore recommend to modify <I>_matherr</I> and <I>_matherrl</I> in such a way that the program is aborted if a DOMAIN error occurs (for an example, see below; alternatively, the UNIX style may be adopted; see the file MATHERR.C supplied with the your C/C++ compiler). Changing the return value of <I>_matherr</I> is another possiblity, but the better way very clearly is to avoid any DOMAIN errors by performing appropriate checks before calling functions like <I><a href="FUNCREF.HTM#sqrt">VF_sqrt</a>,&nbsp; <a href="FUNCREF.HTM#log">VF_log</a>,&nbsp; <a href="FUNCREF.HTM#atan2">VF_atan2</a></I> etc.
<BR><U>For Pascal/Delphi</U>, we recommend not to change the default setting of <a href="FUNCREF.HTM#setFPErrorHandling">V_FPErrorHandlingMode</a> or to include &quot;fperrAbortDOMAIN&quot; in any changes.
<BR>Note: the pseudo-numbers INF and NAN are not allowed as input for any functions of <I>OptiVec</I>. They are not tested for; their presence will normally result in a hardware interrupt.
<LI>SING errors are treated like an extreme case of OVERFLOW (see below). In most cases, they arise from an implicit division by zero or from taking the logarithm of zero. The proposed result is never NAN, but always a &quot;number&quot;, in most cases &#177;HUGE_VAL. Although it is recommended also in the case of SING errors to abort the program and take the necessary measures to avoid them, you may choose to continue program execution.
<LI>OVERFLOW errors are the most abundant form of floating-point errors. They are always handled by proposing +HUGE_VAL or -HUGE_VAL as the result. Within many user algorithms, OVERFLOW errors may occur for intermediate results; if subsequent steps perform operations like taking the inverse, the final result may be acceptable despite the error. Therefore, we recommend to accept the return-value proposal and not to abort the program.
<BR><U>C/C++ only:</U> In principle, you may decide not to accept the return-value proposal of <I>_matherr</I>, but to substitute another one. However, for several reasons you are discouraged from doing that: the correct sign of the result is
set by the calling (&quot;complaining&quot;) function in many cases only after returning from <I>_matherr</I>; the x-value passed to <I>_matherr</I> (which should be inspected before the return value is modified) may either be X<sub>i</sub>
or (as in some of the expanded complex math functions of the <I>VCEx_...</I> family) the intermediate result x' = Ax + B. Note, furthermore, that all x-values are passed to <I>_matherr</I> as double-precision floating-point numbers, also in the case of integer input numbers (like in <I><a href="FUNCREF.HTM#tanrpi">VF_tanrpi</a></I>, where P<sub>i</sub> and q are passed as x and y to <I>_matherr</I>).
<LI>TLOSS (&quot;total loss of precision&quot;) errors are detected only if a more serious error might occur in the respective function. For example, the sine function takes on values between -1 and +1 for all arguments. So, in case of an argument too big for the sine function to be evaluated with any accuracy, the result may nevertheless be &quot;tacitly&quot; set to 0.0 and no call to the <I>OptiVec</I> error handler is generated (whereas Borland C++ chooses NAN, &quot;not a number&quot;, as the result, which is certainly even less correct than arbitrarily choosing 0.0).
<BR>On the other hand, the cosecant, i.e. the inverse of the sine, is not defined for arguments of integer multiples of <font face="symbol">p</font>. Therefore, a more serious error (in this case a SING or an OVERFLOW error) might be hidden under the TLOSS for very big arguments. This possibility is taken into account by calling the error handler, although the proposed result is again set to 0.0 (which is the mean of the two extremes +HUGE_VAL and -HUGE_VAL). Generally, the default result in the case of a TLOSS error is the mean of the results for arguments of +0.0 and -0.0.
<LI>UNDERFLOW errors are never detected; underflowing results are always &quot;tacitly&quot; set to denormal numbers or finally to 0.0 by the floating-point processor itself. Indeed, you may very rarely wish to do something else in this case.
<LI>As in all non-vectorized math functions of the Borland compilers and Visual C++, PLOSS (&quot;partial loss of precision&quot;) errors are never detected and precision problems simply ignored.
</UL>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_4"></a>
<H2>5.4 The Treatment of Denormal Numbers</H2>
&quot;Denormal&quot; are very small numbers between zero and the smallest full-accuracy number available in the respective data type. You may understand the underlying principle from a simplified example: 1.175494E-38 is the smallest &quot;normal&quot; float, with 7-digit accuracy. What about 1/1024 of this value? This can only be represented as
0.001145E-38, which is accurate to only four digits, since the first three digits are needed to hold zeros. Thus, denormal numbers provide a smooth transition between the smallest representable normal numbers and zero.
<P>In general, they may be treated just as ordinary numbers. In some instances, however, like taking the inverse, overflow errors may occur. In these cases, the somewhat academic distinction between SING and OVERFLOW errors is dropped
and a SING error signalled (as if it was a division by exactly 0).
<P>On the other hand, for functions like the logarithms, very small input numbers may give perfectly reasonable results, although the exact number 0.0 is an illegal argument, leading to a SING error. Here, the possible loss of precision is neglected and denormals are considered valid arguments. (This treatment is quite different from that chosen for the math functions of
most compilers, where denormal arguments lead to SING errors also in these cases, which seems less appropriate to us.)
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_5"></a>
<H2>5.5 Advanced Error Handling: Writing Messages into a File</H2>
Quite generally, the libraries shipped with compilers do not offer the programmer much control over the way error messages are printed. While this is fine in most instances, there may be situations in which you might, for example, wish the error messages not to be printed to the screen, but rather into a file, so that you could check later what has gone wrong. An additional motivation could come from the fact that, for any error occurring in a Windows program, a message box is displayed and program execution interrupted until you acknowledge having taken notice of the error.
<P>You might wish to circumvent this. To this end, <I>OptiVec</I> provides the function <I><a href="FUNCREF.HTM#setErrorEventFile">V_setErrorEventFile</a></I>. This function needs as arguments the desired
name of your event file and a switch named <i>ScreenAndFile</i> which decides if the error message is printed only into the file (<i>ScreenAndFile</i> = 0), or additionally into a message box (<i>ScreenAndFile</i> = 1) or, for console programmes, to the screen as well (<i>ScreenAndFile</i> = 2). By calling <I><a href="FUNCREF.HTM#setErrorEventFile">V_setErrorEventFile</a></I>( "NULL", 0 ) (C/C++) or <I><a href="FUNCREF.HTM#setErrorEventFile">V_setErrorEventFile</a></I>( 'nil', 0 ) (Pascal/Delphi), you can even completely switch any messages off (if you decide that is a wise thing to do).
<BR>Note that this redirection of error messages is valid only for errors occurring in <I>OptiVec</I> routines. If you wish to do so, however, there is a way in C/C++ to extend the redirection also to the &quot;non-<I>OptiVec</I>&quot; functions: you may modify <I>_matherr</I> and <I>_matherrl</I> such that the statement 
<BR><font face="courier new"> return 0;</font>
<BR>(which signals an unresolved error) is replaced by the sequence
<BR><font face="courier new"><a href="FUNCREF.HTM#noteError">V_noteError</a>( e-&gt;name, e-&gt;type ); return 1;</font>
<BR>Thereby the task of printing the error message for unresolved errors is passed to the <I>OptiVec</I> function <I><a href="FUNCREF.HTM#noteError">V_noteError</a></I>. Keep in mind that it is the return value of <I>_matherr</I> which decides if an error message is printed by the default error handler of your compiler. Thus, after the call to <I>V_noteError</I>, the printing of the default error messages is by-passed by returning &quot;1&quot;. (Also, do not forget that <I>OptiVec</I> uses <B>your</B> <I>_matherr</I> routine to determine which errors you accept and which not!)
<BR>
<BR>For example, your <I>_matherr</I> function might look like the following one:<font face="courier new">
<BR>#include &lt;math.h&gt;
<BR>int _matherr( struct _exception *e) /* &quot;exception&quot; for older BC++ */
<BR>{
<BR>&nbsp;&nbsp;if( (e-&gt;type == UNDERFLOW) || (e-&gt;type == TLOSS) ) ; /* ignore */
<BR>&nbsp;&nbsp;else /* all other errors deserve at least notice */
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="FUNCREF.HTM#noteError">V_noteError</a>( e-&gt;name, e-&gt;type );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (e-&gt;type == DOMAIN) exit(1); /* really fatal */
<BR>&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;return 1;
<BR>}</font>
<BR>(Of course, if you decide to change <I>_matherr</I>, do not forget to change <I>_matherrl</I> in the same way, if you are using 32-bit BC++!).
<P><U>Both C/C++ and Pascal/Delphi:</U> By calling <I><a href="FUNCREF.HTM#closeErrorEventFile">V_closeErrorEventFile</a></I>, printing into the file is terminated, and <i>OptiVec</i> error messages are emitted according to the value <i>ScreenAndFile</i> which was set upon opening the error event file.
<P>A way to keep track also of those errors which do not lead to messages is opened by the return values of mathematical <I>VectorLib</I> functions. Any of the &quot;silent&quot; TLOSS along with the more serious DOMAIN, SING and OVERFLOW errors will lead to a TRUE (non-zero) return value. You may wish to check for a clean result after a group of functions, like in the following example:<font face="courier new">
<BR>unsigned ErrFlag;
<BR>...
<BR>/* part Trig1 */
<BR>ErrFlag=0; /* reset the flag */
<BR>ErrFlag |= <a href="FUNCREF.HTM#sin">VF_sin</a>( Y1, X1, sz );
<BR>ErrFlag |= <a href="FUNCREF.HTM#cos">VF_cos</a>( Y2, X1, sz );
<BR>ErrFlag |= <a href="FUNCREF.HTM#atan2">VF_atan2</a>( Z1, Y1, Y2, sz );
<BR>if( ErrFlag ) <a href="FUNCREF.HTM#printErrorMsg">V_printErrorMsg</a>( &quot;Errors occurred in part Trig1 ! &quot;);
<BR>...</font>
<BR>As indicated in the example, it is better to use the |= operator (Pascal/Delphi: &quot;ErrFlag := ErrFlag <B>or</B>&quot;) instead of += (since, in rare cases, all return values might add up to 65536, which is stored as 0 due to an overflow of the integer variable). Even if you chose addition of the individual return values, the number of occurred errors would not be obtainable from the result; in case of an error, any non-specified non-zero number is returned.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_6"></a>
<H2>5.6 OptiVec Error Messages</H2>
Just as with any C/C++ or Pascal program, errors occurring within mathematical functions lead to the appropriate error messages. See <a href="#chap5_3_3">paragraph 5.3.3</a> for details.
<BR>Apart from math errors, there are some run-time errors specific to <I>OptiVec</I> routines. These errors lead to the messages noted below. The name of the function where the error occurred is not always exactly the name you wrote
in your program. Instead of the prefix <I>VI_</I>, the message will read <I>VLI_</I> or <I>VSI_</I>, depending on the memory model used. Similarly, instead of <I>VU_</I>, you will find <I>VUL_</I> or <I>VUS_</I>.
<BR><I><a href="FUNCREF.HTM#FFT">VFs_FFT</a></I> or <I><a href="FUNCREF.HTM#FFT">VFl_FFT</a></I> will be substituted for <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I>, again depending on the memory model. The reason for this behavior is that many functions share code and even names.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(00) OptiVec/CMATH not installed correctly<BR>(must use INSTALL.EXE !)</b></font></td></tr></table>
</td></tr></table>
Shareware version only: Either you are running a program containing <I>OptiVec</I> functions on a different computer than the one on which you installed <I>OptiVec</I>. The distribution of applications containing <I>OptiVec</I> functions is possible only with the Registered version.
<BR>Or you attempted to install <I>OptiVec</I> by unzipping the package by hand, without using INSTALL.EXE. This is not possible, as INSTALL.EXE also starts the clock for the trial period. With Windows 2000 / XP, you have to run InitOVBC.EXE (Borland C++ version) or InitOVVC.EXE (MSVC version) instead of INSTALL.EXE.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(0) Trial period for OptiVec/CMATH has expired!</b></font></td></tr></table>
</td></tr></table>
Shareware version only: Consider ordering the registered version!

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(1) Not enough memory. </b></font></td></tr></table>
</td></tr></table>
You are trying to allocate memory, but there is not enough left. This error occurs mostly in connection with &quot;forgotten&quot; vectors that are allocated but never freed. Try these solutions:
<BR>* Look out for vectors that might be no longer needed and free them as soon as possible. Be sure that any vectors allocated in subroutines are freed before leaving the subroutine.
<BR>* Are you still working with 16-bit models? If you need to work with large amounts of data, the memory model FLAT should be used, working with Win32, WindowsNT, or Windows95/98.
<BR>* Store data intermediately on disk, using <I><a href="FUNCREF.HTM#store">VF_store</a></I>, and retrieve them using <I><a href="FUNCREF.HTM#recall">VF_recall</a></I>, when needed. This method is slow and should be used only if really unavoidable.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(2) Vector &gt; 64 kB not possible (16-bit).<BR>
(2) Vector &gt; 4 GB not possible (32-bit).</b></font></td></tr></table></td></tr></table>
* Either you are trying to allocate a vector whose size exceeds the maximum of 4 GB (32-bit) or 64 kB (16-bit except HUGE). 
<BR>* Or you are in the HUGE model and attempt to process a huge vector in a function where the size is limited to 64 kB even in this model. This might happen, e.g., if the table is too large in one of the interpolation routines. In this case, you must either use the model FLAT or split up your problem into smaller vectors.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(3) Vectors/matrices must not be identical.</b></font></td></tr></table>
</td></tr></table>
In some functions where more than one input vector (or matrix) is used to calculate more than one output vector (or matrix), attention has to be paid, which output data may or may not overwrite which input data. See the specification of the function where the error occurred.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(4) Cannot use requested format (too many entries per line).</b></font></td></tr></table>
</td></tr></table>
This error occurs with the printing functions. The parameter <I>nperline</I> was chosen too large. The function automatically selects the maximum <I>nperline</I> possible and continues execution, but you should nevertheless consider adapting your program.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(5) X-values of table must be distinct.</b></font></td></tr></table>
</td></tr></table>
The routines performing interpolations need the tables to be ordered according to their x-values. Each x-value may occur only once, as it is impossible for one and the same x-value to belong to different y-values.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(6) Not possible with fewer than n elements. </b></font></td></tr></table>
</td></tr></table>
Some functions require a minimum size of n elements of the vector processed.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(7) Not possible with more than n elements. </b></font></td></tr></table>
</td></tr></table>
Some functions are limited to a maximum size of n elements. This is true, for example, for <I><a href="FUNCREF.HTM#polyinterpol">VF_polyinterpol</a></I>, where only up to 10 table elements may be used for the each interpolation.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(8) Size must be an integer power of 2. </b></font></td></tr></table>
</td></tr></table>
For all functions using ? explicitly or implicitly ? Fast Fourier Transform methods, the vector size has to be an integer power of 2. Enlarge or truncate your vector(s) to meet that condition.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(9) Invalid parameter(s).</b></font></td></tr></table>
</td></tr></table>
In some functions, certain combinations of input parameters are illegal. For example, it is not possible to perform a 9-point interpolation on only 5 data points.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(10) Cannot scale symbols by more than a factor of 50.</b></font></td></tr></table>
</td></tr></table>
(Windows only.) The symbols used in <I>VectorLib</I> plotting functions cannot be magnified by more than a factor of 50 (which means already filling the screen with a single symbol). Program execution is continued with a value of 50.0.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(11) Cannot use line thicker than 500 pixels.</b></font></td></tr></table>
</td></tr></table>
(Windows only.) The lines used in <I>VectorLib</I> plotting functions cannot be thicker than 500 pixels (which is already nonsense). Program execution is continued with a value of 500.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(12) Cannot free non-existent vector.</b></font></td></tr></table>
</td></tr></table>
You called <I><a href="FUNCREF.HTM#free">V_free</a></I> or <I><a href="FUNCREF.HTM#nfree">V_nfree</a></I> for a vector that has no memory allocated. Program execution is continued without freeing anything.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(21) Invalid dimension(s).</b></font></td></tr></table>
</td></tr></table>
In one way or the other, the dimensions of input or output matrices do not meet the requirements.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(22) Matrix is singular.</b></font></td></tr></table>
</td></tr></table>
In a function requiring regular input matrices, a singular matrix was encountered. Consider alternative functions, designed to handle (nearly) singular matrices.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(23) No convergence achieved.</b></font></td></tr></table>
</td></tr></table>
Some iterative matrix methods may, in very rare cases, fail to achieve convergence.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(24) Only the first n elements of each row can be printed.</b></font></td></tr></table>
</td></tr></table>
This error occurs with the matrix printing functions. The number of columns is too large for the available linewidth. The function automatically selects the maximum number of columns to be displayed and truncates the rows as needed.

<P><a name="chap6"></a>
<HR width="100%"><H1>6. Trouble-Shooting </H1>
In case of problems, please check first if <I>OptiVec</I> is correctly installed (see <a href="#chap1_4">chapter 1.4</a>). If this is the case, carefully check the following points whose violation would inevitably lead to failure.
<UL>
<LI>The choice of the <I>OptiVec</I> library must match your selection of memory model, processor, and environment. You are not going to have much fun with the library VCF4W.LIB (32-bit for C++ Builder) in 64-bit, and the libraries designed for Borland C++ will not work with Visual C++ or any other compiler. Similarly, OVVCMTD.LIB, designed for multi-thread static debug in Visual C++, will not work well in a multi-thread DLL debug or any &quot;release&quot; link.
<LI>You must not use vectors with a size of 0. All functions tacitly assume that the vectors have at least one element and do not waste your computer time testing for that.
<LI>You must not use vectors that are only declared, but have no allocated memory (see the description of <I><a href="FUNCREF.HTM#vector">VF_vector</a></I>). If you did not switch off warnings, you may be warned also by the compiler not to do that (&quot;possible use of xxx before definition&quot;).
<LI>Constant parameters should not exceed 1.E32 for floats, 1.E150 for doubles, or 1.E2000 for long doubles. Normally, these ranges should suffice for any application...
</UL>
Although <I>OptiVec</I> has been tested thoroughly, there is, of course, always the possibility that a problem might have escaped our attention. Should you feel you discovered a &quot;bug&quot; in <I>OptiVec</I>, please try to specify the situation causing the problem as exactly as possible and let us know at <A HREF="mailto:support@optivec.com">support@optivec.com</A>!
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap7"></a>
<HR width="100%"><H1>7. The Include-Files and Units of <I>OptiVec</I></H1>
All <I>OptiVec</I> C/C++ include-files have the same names as the corresponding Pascal/Delphi units. Naturally, the extension is different: &quot;.H&quot; for the C/C++ include-files, &quot;.DCU&quot; for Delphi units. Below, only the names are listed, without the extension.

<P><U>C/C++ only:</U> Declare the use of <I>OptiVec</I> functions with <font face="courier new">#include</font> statements. If you are using MFC (Microsoft Foundation Classes) or the OWL (ObjectWindows Library) with old Borland compilers, the MFC or OWL include-files have to be #included before (!) the <i>OptiVec</i> include-files.

<P><U>Pascal/Delphi only:</U> Declare the use of <I>OptiVec</I> functions with the <font face="courier new">uses</font> clause.

<BR>&nbsp;<table border width="100%">
<tr valign="top"><td width="40%">Include-file (add suffix .H) or unit</td><td>Contents</td></tr>
<tr valign="top"><td><font face="courier new">VecLib</font></td><td>Basic definitions of the data types along with the functions common to all data types (prefix <I>V_</I>) except for the graphics initialization functions. </td></tr>
<tr valign="top"><td><font face="courier new">VFstd, VDstd, VEstd</font></td><td>Floating-point &quot;standard operations:&quot; generation and initialization of vectors, index-oriented manipulations, data-type interconversions, statistics, analysis, geometrical vector arithmetics, Fourier-Transform related functions, I/O operations. </td></tr>
<tr valign="top"><td><font face="courier new">VCFstd, VCDstd, VCEstd,<BR>VPFstd, VPDstd, VPEstd</font></td><td>Standard operations for cartesian and polar complex vectors</td></tr>
<tr valign="top"><td><font face="courier new">VIstd, VBIstd, VSIstd, VLIstd, VQIstd</font></td><td>Standard operations for signed integer vectors</td></tr>
<tr valign="top"><td><font face="courier new">VUstd, VUBstd, VUSstd, VULstd, VUIstd</font></td><td>Standard operations for unsigned integer vectors (<font face="courier new">VUIstd</font> only for C/C++)</td></tr>
<tr valign="top"><td><font face="courier new">VFmath, VDmath, VEmath</font></td><td>Algebraic, arithmetical and mathematical functions for floating-point vectors</td></tr>
<tr valign="top"><td><font face="courier new">VCFmath, VCDmath, VCEmath,<BR>VPFmath, VPDmath, VPEmath</font></td><td>Arithmetical and mathematical functions for complex vectors</td></tr>
<tr valign="top"><td><font face="courier new">VImath, VBImath, VSImath, VLImath, VQImath</font></td><td>Arithmetical and mathematical functions for signed integer vectors</td></tr>
<tr valign="top"><td><font face="courier new">VUmath, VUBmath, VUSmath, VULmath, VUImath</font></td><td>Arithmetical and mathematical functions for unsigned integer vectors (<font face="courier new">VUImath</font> only for C/C++)</td></tr>
<tr valign="top"><td><font face="courier new">Vgraph</font></td><td>Graphics functions for all data types</td></tr>
<tr valign="top"><td><font face="courier new">VFNLFIT, VDNLFIT, VENLFIT</font></td><td>Non-linear fitting functions (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">VFMNLFIT, VDMNLFIT, VEMNLFIT</font></td><td>Non-linear fitting functions for multiple data sets (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">MFstd, MDstd, MEstd</font></td><td>Matrix operations for real-valued matrices</td></tr>
<tr valign="top"><td><font face="courier new">MCFstd, MCDstd, MCEstd</font></td><td>Matrix operations for cartesian complex matrices</td></tr>
<tr valign="top"><td><font face="courier new">Mgraph</font></td><td>Matrix graphics functions for all data types</td></tr>
<tr valign="top"><td><font face="courier new">MFNLFIT, MDNLFIT, MENLFIT</font></td><td>Non-linear fitting functions for Z = f(X, Y) data (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">MFMNLFIT, MDMNLFIT, MEMNLFIT</font></td><td>Non-linear fitting functions for multiple Z = f(X, Y) data sets (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">NEWCPLX</font></td><td>complex class library <I>CMATH</I>; C++ only</td></tr>
<tr valign="top"><td><font face="courier new">CMATH</font></td><td>complex library <I>CMATH</I> for Pascal/Delphi and plain C</td></tr>
<tr valign="top"><td><font face="courier new">CFMATH, CDMATH, CEMATH</font></td><td>C/C++ only: type-specific parts of <I>CMATH</I>.</td></tr>
<tr valign="top"><td><font face="courier new">XMATH</font></td><td>A few non-vectorized math functions needed internally by other <I>OptiVec</I> functions; they are publically accessible (see <a href="FUNCREF.HTM#chap9">chapter 9</a>). C/C++: declares also the sine, cosec, and tangent tables for <a href="FUNCREF.HTM#sinrpi">VF_sinrpi2</a> etc.</td></tr>
<tr valign="top"><td><font face="courier new">FSINTAB2, DSINTAB2, ESINTAB3,<BR>FSINTAB3, DSINTAB3, ESINTAB3</font></td><td>sine tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">FCSCTAB2, DCSCTAB2, ECSCTAB3,<BR>FCSCTAB3, DCSCTAB3, ECSCTAB3</font></td><td>cosecant tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">FTANTAB2, DTANTAB2, ETANTAB3,<BR>FTANTAB3, DTANTAB3, ETANTAB3</font></td><td>tangent tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">VecObj</font></td><td>basic definitions for <I>VecObj</I>, the object-oriented interface for C++</td></tr>
<tr valign="top"><td><font face="courier new">fVecObj, dVecObj, eVecObj</font></td><td><I>VecObj</I> member functions for real-valued vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">cfVecObj, cdVecObj, ceVecObj<BR>pfVecObj, pdVecObj, peVecObj</font></td><td><I>VecObj</I> member functions for complex vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">iVecObj, biVecObj, siVecObj, liVecObj, qiVecObj</font></td><td><I>VecObj</I> member functions for signed-integer vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">uVecObj, ubVecObj, usVecObj, ulVecObj, uiVecObj</font></td><td><I>VecObj</I> member functions for unsigned-integer vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">OptiVec</font></td><td>includes the whole <I>OptiVec</I> package (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">VecAll</font></td><td>includes all <I>VectorLib</I> and CMATH functions  (C or C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">MatAll</font></td><td>includes all <I>MatrixLib</I> functions  (C or C++ only)</td></tr>
</table>&nbsp;
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><HR width="100%"><H1>E N D </H1>
Copyright for <I>OptiVec</I> software and documentation
<BR>&copy; 1996-2017 <I>OptiCode</I> &#x2013; Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>